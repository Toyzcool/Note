# 三. 类和对象

## 1.类

### 1.1 基本概念

- 规则
  - class关键字之后跟着的是类型的名称
- 类与类关系
  - 依赖（uses a）
    - 一个类的方法操纵另一个类的对象 <!--比如使用形参方式发生依赖关系-->
    - 最常见的关系，最明显的关系
    - 设计中应该遵循尽可能减少依赖，依赖越低，耦合越低
  - 聚合（has a）
    - 一个类中包含着另一个类 <!--使用成员变量形式实现聚合关系-->
  - 继承（is a）
- 类加载——重点
  - 见JVM笔记中的类加载
- 存储空间
  - 栈：栈主要存放在运行期间用到的一些局部变量（基本数据类型的变量）或者是指向其他对象的一些引用，因为方法执行时，被分配的内存就在栈中，所以当然存储的局部变量就在栈中咯。当一段代码或者一个方法调用完毕后，栈中为这段代码所提供的基本数据类型或者对象的引用立即被释放
  - 堆：堆主要存放Java在运行过程中new出来的对象，凡是通过new生成的对象都存放在堆中，对于堆中的对象生命周期的管理由Java虚拟机的垃圾回收机制GC进行回收和统一管理。类的非静态成员变量也放在堆区，其中基本数据类型是直接保存值，而复杂类型是保存指向对象的引用，非静态成员变量在类的实例化时开辟空间并且初始化。所以你要知道类的几个时机，加载-连接-初始化-实例化
  - 常量池：常量池是方法区的一部分内存。常量池在编译期间就将一部分数据存放于该区域，包含基本数据类型如int、long等以final声明的常量值，和String字符串、特别注意的是对于方法运行期位于栈中的局部变量String常量的值可以通过 String.intern()方法将该值置入到常量池中
  - 静态域：位于方法区的一块内存。存放类中以static声明的静态成员变量
  - 方法区：是各个线程共享的内存区域，它用于存储class二进制文件，包含了虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。它有个名字叫做Non-Heap(非堆)，目的是与Java堆区分开

### 1.2 字段

- 字段（数据成员） 定义：任何类型的对象

  - 引用：在对象引用的名称后加句点，然后再加上对象内部成员的名称

    ```java
    data.i = 47;
    ```

- 初始化方法

  - 在构造器中设置值

    ```java
    private TestCons(int aAge) {
            this.age = aAge;
        }
    ```

  - 在声明中赋值

    ```java
    private int age = 5;
    ```

  - 在初始化块中赋值（不常见，通常可以在构造器中实现）

    ```java
    {
       int age = 5;
    }
    ```

- 注意

  - **类中变量的赋值操作是在构造方法中完成的——重点**

    <!--实现-->

    ```java
    public class MyTest6{
        int x = 5;
        public MyTest6() {
        }
    }
    ```

    <!--反编译：构造方法-->

    ```java
     public random.grammar2.MyTest6();
        descriptor: ()V
        flags: (0x0001) ACC_PUBLIC
        Code:
          stack=2, locals=1, args_size=1
             0: aload_0
             1: invokespecial #1 // Method java/lang/Object."<init>":()V
             4: aload_0
             5: iconst_5
             6: putfield      #2                  // Field x:I
             9: return
          LineNumberTable:
            line 14: 0
            line 13: 4
            line 15: 9
          LocalVariableTable:
            Start  Length  Slot  Name   Signature
                0      10     0  this   Lrandom/grammar2/MyTest6;
    }
    
    ```

    <!--解析-->

    1. 构造方法的反编译，其中关于x变量的赋值动作在构造方法中

### 1.3 方法、参数和返回值

1. 方法的基本组成：名称、参数列表、返回值、方法体

   ```
   ReturnType methodName(Argument list){method body};
   ```

2. 调用方法：对象名紧跟句点，然后是方法名和参数列表

   <!--这种调用方法被称为 发送消息给对象-->

#### 1.3.1 参数列表

- 规则

  - 参数列表中必须指定每个所传递对象的类型和名称

  - 方法得到的是所有参数值的拷贝

    - 无法修改基本数据类型的值

    - 支持修改对象参数的状态

      原因：形参是对象引用的拷贝，形参和实参指向同一对象，因此修改生效

    - 不支持让对象参数引用一个新的对象

- 关键字return的用法
  - 离开方法：如无需返回值（返回类型为void），可使用return来结束当前方法
  - 传递返回值

- 命令行参数
  - main()函数中的String[] args
  - 能够获取到命令行中的参数并输出，idea需要在项目中添加program arguments

```java
package com.ten;

public class TestArguement {
    public static void main(String[] args) {
        System.out.println("args[0]"+args[0]);
        System.out.println("args[1]"+args[1]);
        System.out.println("args[2]"+args[2]);
    }
}
```

### 1.4 预定义类

- 预定义类 定义：已经预先定义的类 

  <!--比如String类，根加载器已经完成加载，能够直接使用，不需要创建对象-->

### 1.5 类设计技巧

- 一定要保证数据私有性
- 一定要对数据初始化
- 不要在类中使用过多的基本类型（使用其他类来代替）
- 不是所有域都需要独立的域访问和修改器
- 对职责过多的类进行分解（不然会导致耦合过高）
- 类名和方法名能够体现职责
- 优先使用不可变的类

## 2.对象

### 2.1基本概念

- 面向对象的语言有五个特点

  - 万物皆为对象

  - 程序是对象的集合，它们通过发消息来通讯

    <!--一盏电灯是一个程序，灯泡、灯座则为对象-->

  - 每个对象都有自己的由其他对象所构成的存储

  - 每个对象都有类型

  - 某特定类型的所有对象都能收到同样的消息

    <!--父类几何体，子类圆形、正方形，子类对象都能收到几何体类型的信息-->

### 2.2 创建对象——重点

- 规则

  ```java
  new ClassName();
  ```

  <!--实现-->

  ```java
  public class MyTest7 {
      public static void main(String[] args) {
          MyTest7 myTest7 = new MyTest7();
      }
  }
  ```

  <!--反编译-->

  ```java
  0 new #2 <random/grammar2/MyTest7>
  3 dup
  4 invokespecial #3 <random/grammar2/MyTest7.<init>>
  7 astore_1
  8 return
  ```

  <!--解析-->

  1. 创建引用并指向对象流程
     1. 0：创建实例，同时将引用推送到操作数栈顶
     2. 3：复制操作数堆栈上的顶部值，并将重复的值压入操作数堆栈
     3. 4：因为需要创建实例，因此需要调用实例的构造方法，此处调用MyTest7类的构造方法
     4. 7：把引用存储到本地变量表中
     5. 8：返回

- 类实例化流程

  <!--源码-->

  ```java
  public class MyTest7 {
      int age;
  
      public MyTest7(int age) {
          this.age = age;
      }
  
      public static void main(String[] args) {
          MyTest7 myTest7 = new MyTest7(18);
      }
  }
  ```

  <!--解析-->

  1. 对象创建流程
     1. 加载：将.class文件由应用类加载器加载到内存中
     2. 连接中的验证：确保被加载类的正确性
     3. 连接中的准备：为类变量分配内存，并将其初始化为默认值 <!--把age变量初始化为0-->
     4. 连接中的解析：把类中的符号引用转换为直接引用
     5. 初始化：为类的静态变量赋于正确的初始值
     6. 类实例化
        1. 为新的对象分配内存
        2. 为实例变量赋予默认值
        3. 为实例变量赋予正确的初始值

- 引用和对象

  <!--实现-->

  ```java
  String s = new String("abcd");
  ```

  <!--解析-->

  1. 等式右边，是新建一个对象，放置在堆中，并赋值“abcd”，如果括号内为空，则使用新建类的无参构造方法
  2. 等式左边，是新建一个引用，放置在堆栈中
  3. 等号代表将引用指向对象（类似指针），因此一个对象可以有多个引用，但一个引用只有0或1个对象

## 3.方法

### 3.1 构造方法

#### 3.1.1 基本概念

- 规则

  - 使用与类相同的名称，且由于构造器名称需要和类名相同，因此“每个方法首字母小写”的规则不适用于构造器

    原因：第一，名称可能与类中的成员名称冲突；第二，调用构造器是编译器任务，需要让编译器明确识别

  - 类中缺少构造器，则编译器将自动创建默认构造器，且为无参构造器；类中已经定义构造器，则编译器不会创建 

  - 每个类可以有一个及以上的构造器

  - 无参构造器是特殊类型的方法，没有返回值，与返回值为void不同；void类型方法可以修改返回类型，比如将void修改为int，但是构造器没有办法修改

  - **构造器随着new操作符的执行被调用，无法通过构造器重新设置实例域**

- 分类

  1. 默认构造器（无参构造器）
  2. 有参构造器

- 注意

  - 只有在创建对象时，会为对象分配存储空间，同时调用相应的构造器

  - 继承关系中，子类构造方法会调用超类构造方法；如果存在多个构造器，每个构造器都将调用超类的构造方法

    <!--实现-->

    ```java
    public class MyTest6 extends MyTest5{
        int x;
        public MyTest6() {
        }
    
        public MyTest6(int x) {
            this.x = x;
        }
    }
    ```

    <!--反编译-->

    ```java
    public random.grammar2.MyTest6();
        descriptor: ()V
        flags: (0x0001) ACC_PUBLIC
        Code:
          stack=1, locals=1, args_size=1
             0: aload_0
             1: invokespecial #1    // Method random/grammar2/MyTest5."<init>":()V
             4: return
          LineNumberTable:
            line 14: 0
            line 15: 4
          LocalVariableTable:
            Start  Length  Slot  Name   Signature
                0       5     0  this   Lrandom/grammar2/MyTest6;
    
      public random.grammar2.MyTest6(int);
        descriptor: (I)V
        flags: (0x0001) ACC_PUBLIC
        Code:
          stack=2, locals=2, args_size=2
             0: aload_0
             1: invokespecial #1      // Method random/grammar2/MyTest5."<init>":()V
             4: aload_0
             5: iload_1
             6: putfield      #2                  // Field x:I
             9: return
          LineNumberTable:
            line 17: 0
            line 18: 4
            line 19: 9
          LocalVariableTable:
            Start  Length  Slot  Name   Signature
                0      10     0  this   Lrandom/grammar2/MyTest6;
                0      10     1     x   I
    }
    ```

    <!--解析-->

    1. 无参构造器和有参构造器中都调用了超类的无参构造器

#### 3.1.2 隐式参数与显式参数

- 隐式参数：方法名面前的类对象，使用this关键字代表

- 显式参数：传入方法的参数

  <!--实现-->

  ```java
  public class MyTest6 {
      public MyTest6() {
      }
  }
  ```

  <!--反编译-->

  ```java
  public random.grammar2.MyTest6();
      descriptor: ()V
      flags: (0x0001) ACC_PUBLIC
      Code:
        stack=1, locals=1, args_size=1
           0: aload_0
           1: invokespecial #1         // Method java/lang/Object."<init>":()V
           4: return
        LineNumberTable:
          line 13: 0
          line 14: 4
        LocalVariableTable:
          Start  Length  Slot  Name   Signature
              0       5     0  this   Lrandom/grammar2/MyTest6;
  }
  ```

  <!--解析-->

  1. 反编译的args_size显示了当前方法中传入的参数数量为1，并且在LocalVariableTable中，显示了变量，名称为this，即构造方法中的隐式参数

#### 3.1.3 构造方法嵌套调用

- 规则

  - 能够在构造器中调用构造器
  - 不能调用两个
  - 构造器调用需要置于最起始位置

- 实现

  ```java
  class TestThis {
      String s = "initial value";
      int i;
      // 有参构造器
      TestThis(String s,int i){
          System.out.println("Build s and i");
      }
      // 无参构造器使用this调用
      TestThis(){
          this("This",32);
      }
      public static void main(String[] args) {
          TestThis testThis = new TestThis();
      }
  }
  ```

### 3.2 方法重载

- 规则
  1. 名称相同
  2. 参数不同，类型、数量、顺序 （参数名称不同不构成重载）

#### 3.2.1 基本类型的重载

- 规则

  - 如果传入的参数类型大于重载方法声明的类型，则窄化转换

    ```java
    public class TestOverride {
        void f1(int f){
            System.out.println(getType(f));
            System.out.println(f);
        }
        public static String getType(Object object){
            String typeName=object.getClass().getName();
            int length= typeName.lastIndexOf(".");
            String type =typeName.substring(length+1);
            return type;
        }
        public static void main(String[] args) {
            TestOverride testOverride = new TestOverride();
            testOverride.f1(100);
            // 窄化转换
            testOverride.f1((int) 3000.08);
        }
    }/* output
    Integer
    100
    Integer
    3000
    */
    ```

  - 如果传入的参数类型小于重载方法声明的类型，则提升数据类型

    ```java
    public class TestOverride {
        void f1(double f){
            System.out.println(getType(f));
            System.out.println(f);
        }
        public static String getType(Object object){
            String typeName=object.getClass().getName();
            int length= typeName.lastIndexOf(".");
            String type =typeName.substring(length+1);
            return type;
        }
        public static void main(String[] args) {
            TestOverride testOverride = new TestOverride();
            testOverride.f1(100);
            testOverride.f1(3000.08);
        }
    }/* output
    Double
    100.0
    Double
    3000.08
    */
    ```

  - 无法以返回值区分重载方法

    原因：如果不获取返回值，仅仅使用f()方法，是无法区分的

### 3.3 方法重写

- 规则
  - 超类和子类中的方法签名相同（方法名和参数列表），返回值类型需要保证一样或者是返回值类型的子类（协变返回类型）

#### 3.3.1 重写和重载——重点

- 区别

  - **重载是静态行为，是编译期行为；重写是动态行为，是运行期行为**

    需要确认方法的调用者

  - 重写是方法签名相同

     <!--方法签名是方法的名称和参数类型-->；

    重载是方法名相同，参数列表必须不同，对返回类型，访问修饰符，异常声明没有任何限制

     <!--可以看作一个新方法，只是方法名称特殊-->

- 实现：证明重载是静态行为

  <!--代码-->

- ```java
  public class MyTest4 {
      public void test(Grandpa grandpa){
          System.out.println("Grandpa");
      }
      public void test(Father father){
          System.out.println("Father");
      }
      public void test(Son son){
          System.out.println("Son");
      }
  
      public static void main(String[] args) {
          Grandpa p1 = new Father();
          Grandpa p2 = new Son();
  
          MyTest4 myTest4 = new MyTest4();
          
          myTest4.test(p1);
          myTest4.test(p2);
      }
  }
  
  class Grandpa{}
  class Father extends Grandpa{}
  class Son extends Father{}
  
  /* output
  Grandpa
  Grandpa
  */
  ```

  <!--反编译-->

  ```shell
   0 new #7 <ByteCode/Father>
   3 dup
   4 invokespecial #8 <ByteCode/Father.<init>>
   7 astore_1
   8 new #9 <ByteCode/Son>
  11 dup
  12 invokespecial #10 <ByteCode/Son.<init>>
  15 astore_2
  16 new #11 <ByteCode/MyTest4>
  19 dup
  20 invokespecial #12 <ByteCode/MyTest4.<init>>
  23 astore_3
  24 aload_3
  25 aload_1
  26 invokevirtual #13 <ByteCode/MyTest4.test>
  29 aload_3
  30 aload_2
  31 invokevirtual #13 <ByteCode/MyTest4.test>
  34 return
  ```

  <!--解析-->

  **1.p1和p2的静态类型是Grandpa，p1的实际类型是Father，p2的实际类型是Son。静态类型不会发生改变，动态类型能够在运行期改变**

  **2.方法的重载属于静态行为，因此test方法在编译期间确定调用的就是p1和p2的静态类型，也就是Grandpa，因此输出结果都为Grandpa**

  **3.方法的调用者为MyTest4类的对象**

- 实现：证明方法重写是动态行为

  <!--代码-->

  ```java
  public class MyTest5 {
      public static void main(String[] args) {
          Fruit apple = new Apple();
          Fruit orange = new Orange();
  
          apple.test();
          orange.test();
      }
  }
  
  class Fruit{
      public void test(){
          System.out.println("Fruit");
      }
  }
  class Apple extends Fruit{
      @Override
      public void test(){
          System.out.println("Apple");
      }
  }
  class Orange extends Fruit{
      @Override
      public void test(){
          System.out.println("Orange");
      }
  }
  /* output
  Apple
  Orange
  */
  ```

  <!--反编译-->

  ```shell
   0 new #2 <ByteCode/Apple>
   3 dup
   4 invokespecial #3 <ByteCode/Apple.<init>>
   7 astore_1
   8 new #4 <ByteCode/Orange>
  11 dup
  12 invokespecial #5 <ByteCode/Orange.<init>>
  15 astore_2
  16 aload_1
  17 invokevirtual #6 <ByteCode/Fruit.test>
  20 aload_2
  21 invokevirtual #6 <ByteCode/Fruit.test>
  24 return
  ```

  <!--解析-->

  1. 执行流程
     1. 0：新建Apple对象
     2. 3：将对象复制到栈顶
     3. 4：调用Apple构造方法
     4. 7：返回apple对象的存储地址
     5. 16：从栈顶取出apple对象
     6. **17：invokevirtual指令的逻辑是：编译期间，由于是Fruit类，因此指向的是Fruit中的test方法；但是在运行期，会查找apple变量指向的实际类型，查找所指对象中是否存在test方法，如果存在且符合权限访问，则调用。如果不存在或不符合则向上（父类）查找 <!--虽然#6指向的是Fruit中e的test方法，但是invokevirtual在运行期会先查找变量指向的实际类型-->**
  2. 方法的重写是属于动态行为
  3. 方法的调用者是apple对象

- 实现：多态中常见的一个问题

  <!--代码-->

  ```java
  class Father{
    void test1(){};
  }
  class Son extends Father{
    // 子类的私有方法
    void test2(){};
  }
  
  public class Test{
    public static void main(String[] args){
      Father son = new Son();
      son.test2;
    }
  }
  /* output
  编译期间报错
  */
  ```

  <!--解析-->

  1. **invokevirtual的逻辑，在反编译中会指向 Father.test2，但是此方法并不存在。在编译期间，son的静态类型是Father，因此invokevirtual会在Father类中查找test2方法，但是无法找到，所以会在编译期间报错**

### 3.4 参数可变的方法

- 参数可变 定义：支持用可变的参数数量调用的方法

- 格式

  ```java
  // 使用 ...
  Double ... args
  ```

  <!--比如System.out.printf()方法，能够接收多个参数-->

  ```java
  // 同时接收多个参数
  System.out.printf("%d %s",n,"name");
  
  // 底层实现代码
  public PrintStream printf(String format, Object ... args) {
          return format(format, args);
      }
  /* conclusion
  1.“String format”为格式字符串，“Object ... args”为Object对象的数组，因此数量可变
  */
  ```

  <!--实现：使用参数可变实现查找最大值-->

  ```java
  public class TestFindMax {
      static void findMax(Object ... args){
          double largest = Double.NEGATIVE_INFINITY;
          for (Object y: args
               ) {
                  Double z = (Double) y;
                  if (z > largest)
                      largest = z;
          }
          System.out.println(largest);
      }
  
      public static void main(String[] args) {
          TestFindMax.findMax(3.454,34.3);
      }
  }
  ```

## 4.封装

### 4.1 封装的优点

#### 1.域访问器

- 定义：返回实例域值的机器

- 组成

  - 私有数据域
  - 公有的域访问器方法
  - 公有的域更改器方法

- 格式：public修饰，返回值为实例域值

  <!--实现-->

  ```java
  // 需求：返回薪水值
  public class Worker{
    private int salary;
  }
  // 域访问器
  public int getSalary(){
    return salary;
  }
  ```

- 优势

  - 支持修改内部实现，不影响其他代码
  - 支持执行错误检查 <!--比如判断传入数据是否为空-->

- 注意

  - 如果需要返回一个可变数据域的拷贝，使用clone()

    <!--实现-->

    ```java
    class E{
    	...
        public Date getH(){
        return (Date)hire.clone();
      }
    }
    ```

## 5.关键字

### 5.1 Static

#### 5.1.1 基本概念

- 作用：实现不创建对象也能访问变量以及方法

- 作用域

  - 作用于域（类变量、类方法等），不能作用于局部变量

    原因：static会分配指定存储空间，但比如类方法中的局部变量，在方法执行完毕后，局部变量将被垃圾回收，因此无法用static关键字

- 规则

  - 为某特定域分配单一的存储空间

    <!--实现-->

    ```java
    class StaticTest(){
     static int i = 47;
    }
    StaticTest st1 = new StaticTest();
    StaticTest st2 = new StaticTest();
    //即使创建两个对象，StaticTest.i也仅有一份存储空间
    ```

#### 5.1.2 静态域

- 静态域 定义：被static修饰的域

- 规则

  - 静态域属于类，不属于对象

    <!--也就是所有对象共享一个静态域-->

  - 在类初始化阶段执行

    <!--实现-->

    ```java
    static class Parent{
      public static int A = 1;
      static{
        A = 2
      }
    }
    
    static class Sub extends Parent{
      public static int B = A ;
    }
    
    public static void main(String[] args){
      System.out.println(Sub.B);
    }
    /* output
    2
    */
    ```

    <!--解析-->

    1. main方法中访问静态变量Sub.B，造成静态类Sub的初始化
    2. 由于Sub继承Parent类，因此会优先初始化Parent类，因此先将静态变量A赋值为1，然后静态代码块将A赋值为2
    3. 再执行Sub类中的将A的值赋给B，因此B的值为2

#### 5.1.3 静态常量

- 常用的静态常量

  - Math.PI

    <!--实现-->

    ```java
    // 定义
    public class Math {
        public static final double PI = 3.123453454354535345;
    }
    // 使用
    public class TestMath {
        public static void main(String[] args) {
            int l = 5;
            double circle = l*l*Math.PI;
            System.out.println(circle);
        }
    }
    ```

  - System.out

#### 5.1.4 静态方法

- 定义：不能向对象实施操作的方法 （静态方法是没有this参数的方法）

  原因：static方法中不能调用非静态方法，静态方法在类加载阶段已经将符号引用转换成直接引用（直接引用代表已经在内存中），而非静态方法需要等待对象实例化

- 作用

  - 实现不创建对象的前提下，通过类本身来调用static方法
  - 方法不需要访问对象状态，所需参数都是通过显示参数提供 <!--比如Math.pow-->
  - 方法只需要访问类的静态域 <!--比如返回静态域内容的get方法-->

#### 5.1.5 工厂方法

- 定义：静态方法模式，支持返回预期的对象

- 步骤

  - 创建抽象产品类，定义公共的接口 <!--需要获得工厂中多种对象，返回方法的变量类型能够统一-->

  - 创建具体产品类

  - 创建工厂类，创建静态方法来返回具体产品类

  - 外部类调用工厂类中的静态方法获得相应的产品对象

    <!--实现-->

    ```java
    // 抽象产品类，方便产生多种产品类型
    abstract class Product {
        protected abstract void show();
    }
    ```

    ```java
    // 具体产品类1
    public class Product1 extends Product {
        @Override public void show() {
            System.out.println("Product1");
        }
    }
    
    // 具体产品类2
    public class Product2 extends Product {
        @Override public void show() {
            System.out.println("Product2");
        }
    }
    
    // 具体产品类3
    public class Product3 extends Product {
        @Override public void show() {
            System.out.println("Product3");
        }
    }
    ```

    ```java
    // 工厂类，根据传入参数类型返回相应的对象
    public class ProductFatory {
        public static Product getProduct(String s){
            switch (s){
                default:return null;
                case "a" :return new Product1();
                case "b" :return new Product2();
                case "c" :return new Product3();
            }
        }
    }
    ```

    ```java
    // 测试类
    public class TestFactory {
        public static void main(String[] args) {
            ProductFatory.getProduct("a").show();
            ProductFatory.getProduct("b").show();
            ProductFatory.getProduct("c").show();
        }
    }
    /* output 
    Product1
    Product2
    Product3
    */
    ```

- Pros

  - 创建实例和使用实例解耦

- Cons

  - 工厂类出现错误时，整个系统受到影响
  - 违背“开放-关闭原则”，新增类需要修改工厂逻辑，工厂类将冗杂

#### 5.1.6 静态导入

- 作用：方法中调用静态导入的其他类中的静态方法

- 实现

  <!--类和静态方法-->

```java
package com.one;
public class Print {
    public static void print(String s){
        System.out.println(s);
    }
}
```

​    <!--测试静态导入的方法-->

```java
package com.one;
// 静态导入方法
import static com.one.Print.*;
public class TestPrint {
    public static void main(String[] args) {
        System.out.println("Nomal Print");
        // 静态导入的方法输出
        print("Simple Print");
    }
}
```

### 5.2 This

- 作用
  - **表示对“调用方法的那个对象”的引用，就是当前类的对象的引用**
  - 能够将当前对象传递给其他方法
- 规则
  - 只能在方法内部使用
  - 如果在方法内调用一个类中的方法，则不需要this关键字
  - 类中的方法中的一个隐式参数，详情见 <u>3.1.2 隐式参数和显式参数</u>

### 5.3 Final

#### 5.3.1 final数据

- 规则

  - 可以修饰类、函数、变量
  - 被final修饰的类不可以被继承
  - 被final修饰的方法不可以被重写
  - 被final修饰的变量不可变

- final一般用于基本类型数据，代表的常量

  - final用于引用类型时，表示无法将当前引用指向另一个新的对象
  - final基本类型称为恒定初始值，全部用大写字母命名

- final和static

  1. final和无final区别

     - a能够重新赋值；b在程序中无法重新赋值

     ```java
     int a = 1;
     final int b = 1; 
     ```

  2. **final和final static区别**

     - public static final成为全局常量，不需要创建对象即可访问

     - c无法重新赋值，用完后被垃圾回收器回收;d无法重新赋值，用完后依旧占据内存，直至程序终止**

       ```java
       final int c = 5;
       final static int d = 10;
       ```

     - **final static在装载时已经初始化，并且仅初始化一次，因此新建对象时值已经确定;final 需要在新建对象时赋值，因此新建两个对象中的fi值不同**

       ```java
       public class TestFinalStatic {
           static Random random = new Random(20);
           // final static 的恒定初始值
           final static int a = random.nextInt(20);
           // final 常量
           final int b = random.nextInt(20);
       
           public static void main(String[] args) {
               TestFinalStatic testFinalStatic = new TestFinalStatic();
               System.out.println("对象1");
               System.out.println("b:"+testFinalStatic.b);
               System.out.println("a:"+a);
               System.out.println("");
               System.out.println("对象2");
               TestFinalStatic testFinalStatic2 = new TestFinalStatic();
               System.out.println("b:"+testFinalStatic2.b);
               System.out.println("a:"+a);
           }
       }/* output
       对象1
       b:16
       a:13
       
       对象2
       b:1
       a:13
       */
       ```

##### 1. 空白final

- 规则

  允许生成空白final，但是必须在定义处或者是构造方法中执行初始化

  ```java
  class BlankFinal{
    final int i = 0;
    final int k;
    BlankFinal(){
      k = 3;
    }
  }
  ```

##### 2. final参数

- 规则

  在参数列表中以声明的方式将参数指明为final，表示无法更改参数引用所指向的对象

  ```java
  class Gizmo{}
  public class FinalArguments{
  	void with(final Gizmo g)
      // g = new Gizmo(); 这是非法的，因为无法更改参数引用指向的对象
  }
  ```

- 作用：向匿名内部类传递数据

#### 5.3.2 final方法

- 规则

  当用final关键字修饰方法后，该方法在子类中将无法重写，只能继承

- 作用

  - 防止继承类修改
  - ~~效率，将该方法的所有调用都转为内嵌调用~~  已经不适用

##### 1. final和private关键字

> private默认是final的，在java的早期版本中使用private final来表达，从而提升性能。而在java2后，private默认也就是final的了，不需要在加上final的描述

#### 5.3.3 final类

- 规则

  无法被继承

- 用途

  final关键字将为这些方法提供安全，没有任何人能够重写final类中方法







