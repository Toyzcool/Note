# 四.复用类

## 1. 复用

- 分类
  - 组合：在新的类中生成现有类的对象
  - 继承：按照现有类的类型创造新类，采用现有类的形式并添加新代码

## 2. 组合

- 组合 定义：在类中创建现有类的对象

- 初始化引用的方式

  1. 定义对象时初始化。能够在构造器调用前初始化

  2. 在类的构造器中

  3. 需要使用时才初始化（也称为惰性初始化）。可减少负担

  4. 使用实例初始化

     <!--实现-->

```java
public class ReferenceInitialization {
    private Reference1 reference4;
    // 1.在定义对象时初始化引用
    private Reference1 reference1 = new Reference1("1.在定义对象时初始化引用") ;

    ReferenceInitialization(){
        // 2.在类的构造器中初始化引用
        Reference1 reference2 = new Reference1("2.在类的构造器中初始化引用");
    }

    // 4.使用实例初始化
    {
        reference4 = new Reference1("4.使用实例初始化");
    }

    public static void main(String[] args) {
        ReferenceInitialization referenceInitialization = new ReferenceInitialization();
        // 3.需要使用对象时，才初始化引用
        Reference1 reference3 = new Reference1("3.需要使用对象时，才初始化引用");
    }
}
```

```java
public class Reference1 {
    protected Reference1(String s){
        System.out.println(s);
    }
}
```

## 7.2 继承语法

> 创建类时，总是在继承。因为创建的类基本是隐式继承Object类

#### 1.基本概念

- 继承的优点

  - 提高代码复用性
  - 让类与类产生关系，是实现多态的基础

- 使用规则

  - 基类的所有数据成员为private类型，所有方法为public或者protected类型，这是推荐使用的规则

  - 继承自超类的子类，能够访问超类中的数据成员和方法（非private类型）

  - 子类中调用超类方法，使用super.方法名关键字 

  - 子类中能够直接添加新方法

  - 类不能多继承，但支持多层继承

    原因是：子类多继承后，如果存在名称相同的方法，无法确定执行

#### 2.覆盖

- 覆盖（重写）定义：当子类出现和父类相同的函数
- 规则
  - 子类覆盖父类，必须保证子类权限大于等于父类
  - 静态只能覆盖静态（基本没有人使用）
- 注意点
  - 重载是看同名函数的参数列表
  - 重写是子父类方法一模一样（包括返回值类型，但返回值类型可以为其子类型） <!--因为使用方法时，无法知道运行那个方法-->

<!--实现-->

```java
public class Detergent extends Cleanser {
    // 覆盖方法
    public void protectedPrint(){
        System.out.println("覆盖超类的protectedPrint()");
        super.protectedPrint();
    }

    public void sterilize(){
        System.out.println("子类的新方法");
    }

    public static void main(String[] args) {
        System.out.println("1.覆盖超类的方法");
        Detergent detergent = new Detergent();
        detergent.protectedPrint();
        System.out.println("");
        System.out.println("2.子类的新方法");
        detergent.sterilize();
        System.out.println("");
        System.out.println("3.子类调用超类的方法");
        detergent.publicPrint();
    }
}/* output
1.覆盖超类的方法
覆盖超类的protectedPrint()
super protected method

2.子类的新方法
子类的新方法

3.子类调用超类的方法
super public method
*/
```

```java
// 基类
public class Cleanser {
    public void publicPrint(){
        System.out.println("super public method");
    }
    protected void protectedPrint(){
        System.out.println("super protected method");
    }
    private void privatePrint(){
        System.out.println("super private method");
    }
}
```

- 如何使用继承体系中的功能

  - 查阅父类功能，创建子类对象使用功能

    原因是：父类存在无法创建对象的情况（比如抽象类），并且使用子类能够使用更多的功能

### 7.2.1 初始化基类

- 注意点

  - 子类无法覆盖父类的构造函数，因为不同名

  - **子类的所有构造函数都默认访问父类的空参构造函数（因为有隐式super语句），如果**

    原因：因为父类数据可以被子类获取，所以子类在创建对象时，需要参考父类是如何对这些数据进行初始化的

    <!--验证-->

    ```java
    // 基类
    public class Art {
        Art(){
          System.out.println("Art Constructor");
        };
    }
    ```

    ```java
    // 导出类
    public class Drawing extends Art{
        Drawing(){
        	//导出类构造函数中存在隐式的基类构造语句
         		// super();
            System.out.println("Drawing Constructor");
        }
    }
    ```

    ```java
    // 基类的子类的子类
    public class Cartoon extends Drawing {
            Cartoon(){
                System.out.println("Cartoon Constructor");
            }
        public static void main(String[] args) {
            Cartoon cartoon = new Cartoon();
        }
    }/* output
    Art Constructor
    Drawing Constructor
    Cartoon Constructor
    */
    ```

  - 仅定义的对象类型的成员（未在定义时初始化），在类创建时，不会调用对象类型的构造方法

    ```java
    public class ClassA {
        public ClassA() {
            System.out.println("ClassA Constructor");}}
    ```

  ```
    ```java
    public class ClassB {
        public ClassB() {System.out.println("ClassB Constructor");}}
  ```

  ```java
    public class ClassC extends ClassA{
    		// 对象类型的成员，仅创建引用，但是没有指向任何一个对象，因此不会发生实例化
        public ClassB classB;
        public static void main(String[] args) {
            ClassC classC = new ClassC();
        }
    }/* output
    ClassA Constructor
    */
  ```

  - 如果基类中有带参数的构造器，没有默认的构造器，或者是想调用基类的含参构造器，需要使用super(参数)方法来调用基类的含参构造器，并放在构造器起始位置。

    <!--验证-->

    ```java
    // 基类
    public class Art {
        Art(int i){
            System.out.println("Art Constructor:"+i);
        };
    }
    ```

    ```java
    // 基类的子类
    public class Drawing extends Art{
        Drawing(int i){
          	// 调用基类的有参构造器，super(s)将s的值传输到基类中使用
            super(i);
            System.out.println("Drawing Constructor:");
          	// super(1); 需要将初始化基类放在起始位置，不然编译器会报错
        }
    }
    ```

    ```java
    // 基类的子类的子类
    public class Cartoon extends Drawing {
            Cartoon(int i){
            		super(i)
                System.out.println("Cartoon Constructor:"+i);
            }
        public static void main(String[] args) {
            Cartoon cartoon = new Cartoon(11);
        }
    }/* output
    Art Constructor:11
    Drawing Constructor:11
    Cartoon Constructor:11
    */
    ```

  - 子类的构造函数第一行也能通过this来访问本类中的构造函数，但是必定有本类中的构造函数会访问父类的构造函数。同时this和super都必须在第一行

    ```java
    // 基类
    public class Art {
        Art(){
            System.out.println("Art Constructor:");
        };
    }
    
    ```

    ```java
    // 基类的子类
    public class Drawing extends Art{
      Drawing(){
        // 当前构造器将调用基类构造器，同时当前构造器被本类中的有参构造器调用
        System.out.println("Drawing Constructor:");
      }
        
      Drawing(int i){
        // 使用this关键字，因此会调用当前类的无参构造器
        this();
        System.out.println("Drawing Constructor:"+i);
      }
    }
    ```

    

