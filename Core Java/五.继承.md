# 五.继承

- 继承 定义：基于已有的类构造新类
- 反射 定义：在程序运行期间发现更多的类以及属性的能力
- 多态 定义：一个对象变量可以指示多种实际类型的现象
- 动态绑定 定义：在运行时能够自动选择调用方法的现象

## 5.1 类、超类和子类

### 5.1.2 覆盖方法

- 规则
  - 超类和子类中的方法签名相同（方法名和参数列表），返回值类型需要保证一样或者是返回值类型的子类（协变返回类型）
- 覆盖和重载的区别
  - 覆盖是方法签名相同
  - 重载是方法名相同，参数列表必须不同，对返回类型，访问修饰符，异常声明没有任何限制 <!--可以看作一个新方法，只是方法名称特殊-->

### 5.1.6 方法调用流程

- 图解

![](/Users/toyz/Package/Note/Core Java/assets/5.方法调用流程.png)

### 5.1.7 阻止继承：final类和方法

- 规则
  - 类用final修饰后，无法被继承，其中的方法也自动用final修饰。域不包括
  - 方法用final修饰后，子类无法覆盖当前方法

### 5.1.8 强制类型转换

- 注意
  - 强制类型转换前，使用instanceof方法判断是否为所属类型

## 5.2  Object:所有类的超类

- 注意：只有基本类型不是对象

### 5.2.1 equals

- 特点
  - 自反性：x为任何非空引用，x.equals(x)应该返回true
  - 对称性：对于任何引用x，y，当且仅当x.equals(y)返回true，则y.equals(x)返回也为true
  - 传递性：对于任何引用x，y，z，如果x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)返回也为true
  - 一致性：如果x，y引用的对象没有变化，则x.equals(y)应一直返回true
- equals和等号的区别——重点
  - 等号（==）
    - 基本数据类型（也称原始数据类型） ：byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。
    - 引用数据类型：当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址（确切的说，是**堆内存**地址）
  - equals
    - 方法的初始默认行为是比较对象的内存地址值
    - **在一些类库当中这个方法被重写了，如String、Integer、Date，比较对象的成员变量值是否相同**
- 合理的equals重写逻辑
  1. 显示参数声明为Object <!--覆盖equals方法-->
  2. 判断是否引用同一对象 <!--相比于判断域，当前判断成本低-->
  3. 判断是否为空
  4. 判断是否属于同一类 <!--使用getClass()和instanceof-->
  5. 将比较对象转换成相应类型的变量
  6. 域的比较 <!--使用==比较基本类型域，使用equals比较对象域-->

### 5.2.3 hashCode方法

- 散列码（hash code） 定义：是由对象导出的一个整型值 <!--对象才有，因此基本数据类型需要转成包装类-->

- 注意

  - 字符串和基本数据类型的包装类创建的对象存在hashCode相同的情况，因为是由内容导出的

    <!--实现-->

    ```java
    public class TestHashCode {
        public static void main(String[] args) {
            String s1 = "a";
            String s2 = "a";
            Integer i = 10;
            Integer k = 10;
            System.out.println(s1.hashCode());
            System.out.println(s2.hashCode());
            System.out.println(s1.equals(s2));
            System.out.println(i.hashCode());
            System.out.println(k.hashCode());
            System.out.println(i.equals(k));
        }
    }/* output
    97
    97
    true
    10
    10
    true
    */
    ```

  - 如果重新定义equals方法，就必须重新定义hashCode方法，以便用户可以将对象插入到散列表中。如果重新定义，会出现equals相等，hashCode不等——考点

    <!--equals与hashCode的定义必须一致，两个对象equals为true,就必须有相同的hashCode。反之则不成立。-->

    <!--如果定义的equals比较的是雇员ID，那么hashCode就需要散列ID，而不是雇员的姓名或住址-->

### 5.2.4 toString方法

- 用途：返回表示对象值的字符串

- 注意

  - toString方法常见的原因：当对象与一个字符串通过操作符+连接，编译将自动使用toString方法

    <!--实现-->

    ```java
    public class TestToString {
        String name = "asd";
    
        public static void main(String[] args) {
            TestToString testToString = new TestToString();
            System.out.println(testToString+"jkl");
        }
    }/* output
    Five.TestToString.TestToString@1218025cjkl
    */
    ```

  - 建议重写toString方法，默认调用的方法可读性较差

    <!--实现-->

    ```java
    public class TestToString {
        String name = "asd";
    
        @Override public String toString() {
            return "TestToString{" + "name='" + name + '\'' + '}';
        }
    
        public static void main(String[] args) {
            TestToString testToString = new TestToString();
            System.out.println(testToString+"jkl");
        }
    }/* output
    TestToString{name='asd'}jkl
    */
    ```

### 5.2.5 getClass方法

- 用途：返回包含对象信息的类对象

  <!--实现-->

  ```java
  public class TestToString {
      String name = "asd";
  
      public static void main(String[] args) {
          TestToString testToString = new TestToString();
          System.out.println(testToString.getClass());
      }
  }/* output
  class Five.TestToString.TestToString
  */
  ```

## 5.3 泛型数组列表

- 泛型 定义：Java 泛型的参数只可以代表类，不能代表个别对象

#### 1.ArrayList

- 定义：采用类型参数的泛型类

  <!--实现-->

  ```java
  // 使用方法
  ArrayList<Employee> staff = new ArrayList<Employee>();
  // 泛型的类型为Employee
  ```

- 规则

  - 使用add方法增加新数据。如果空间用尽，则自动创建更大的数组，并将原数据拷贝到更大的数组中
  - 使用size方法获取实际元素数量
  - 使用trimToSize将清除多余的存储空间
  - 使用get和set方法访问和设置元素

- 注意

  - 数组列表和数组大小的核心区别：数组分配100的空间是已经在内存中存在的；数组列表在仅是具备存储100的潜力，即使是完成了初始化之后
  - 使用时，指定泛型的类型。因为不指定泛型类型，存储和修改数据接受任意类型对象，因为使用的是Object

## 5.4 对象包装器和自动装箱

























































