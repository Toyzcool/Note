



# 九.集合

## 9.1 Java集合框架

### 9.1.1 将集合的接口与实现分离

- 特点：java集合类库将接口与实现分离

- 集合分类
  - Set代表无序、不可重复的集合
  - List代表有序、重复的集合
  - Map则代表具有映射关系的集合
  - Queue体系集合，代表一种队列集合实现
  
- 各类的特点

  ![](/Users/space/Documents/Package/Note/Core Java/assets/9.2集合框架特点.jpg)

### 9.1.2 Collection接口

- 简介：集合类的基本接口是Collection接口

- 方法

  ```java
  public interface Collection<E>{
    boolean add(E element); // 添加元素
    Iterator<E> iterator(); // 返回实现Iterator接口的对象，可使用该对象遍历集合中的元素
  }
  ```
  
- 接口继承树

  <!--Map接口没有继承自Collection接口，因为Map表示的是关联式容器而不是集合-->
  
  ![](/Users/space/Documents/Package/Note/Core Java/assets/9.3Collection接口继承.png)

### 9.1.3 迭代器

- 特点

  - 所有Collection类(List、Set、Deque)们都可以使用的迭代器
  - 支持三种操作：hasNext()、next()、remove()
  - 存在失效的情况。<!--如果数组重新分配空间，则之前生成的迭代器将失效-->
  
- 方法

  ```java
  public interface Iterator<E>{
    E next(); // 逐个访问元素
    boolean hasNext(); // 判断是否下一个元素是否存在
    void remove(); // 删除刚刚next的元素
    default void forEachRemaining(Consumer< ? super E> action);
  }
  ```

- 用途：提供遍历容器中元素的方法

  <!--实现：使用迭代器和for-each遍历输出，for-each底层实现为迭代器-->

  ```java
  public class TestIterator {
      public static void main(String[] args) {
          List<String> list = new ArrayList<>();
          list.add("A");
          list.add("B");
          list.add("C");
          // 迭代器实现遍历
          Iterator<String> iterator = list.iterator();
          while (iterator.hasNext()){
              System.out.println(iterator.next());
          }
          // for-each实现遍历
          for (String s : list) {
              System.out.println(s);
          }
      }
  }
  ```
  
  
  
- 注意

  - Java迭代器位于两个元素之间，调用next时，越过下个元素，并返回刚刚越过的元素

    ![](/Users/space/Documents/Package/Note/Core Java/assets/9.迭代器移动指针.jpg)
    
  - next方法和remove方法互相依赖。使用remove前需要先调用next，因此无法连续调用remove方法删除两个相邻的元素。原因如上

### 9.1.5 集合框架中的接口

- 集合基本接口：Collection和Map

## 9.2 具体的集合

- 集合类型表

  | 集合类型        | 描述                                       |
  | --------------- | ------------------------------------------ |
  | ArrayList       | 支持动态增长和缩减的索引序列               |
  | LinkedList      | 支持在任意位置高效插入和删除操作的有序序列 |
  | ArrayDeque      | 使用循环数组实现的双端队列                 |
  | HashSet         | 没有重复元素的无序集合                     |
  | TreeSet         | 有序集                                     |
  | EnumSet         | 包含枚举类型值的集                         |
  | LinkedHashSet   | 支持记住元素插入次序的集                   |
  | PriorityQueue   | 支持高效删除最小元素的集合                 |
  | HashMap         | 存储键/值关联的数据结构                    |
  | TreeMap         | 键值有序排列的映射表                       |
  | EnumMap         | 键值属于枚举类型的映射表                   |
  | LinkedHashMap   | 支持记住键/值项添加次序的映射表            |
  | WeakHashMap     | 其值无用后支持被垃圾回收器回收的映射表     |
  | IdentityHashMap | 用== 而不是equals比较键值的映射表          |

### 9.2.1 链表

#### 1.LinkedList

- 特点

  - 同时实现了List接口和Deque接口
  - 非线程安全，不同步 <!--如果需要实现同步，通过Collections.synchronizedList()方法对其进行包装-->

- 结构：双向链表

  - 每个结点存放着数据以及上一结点和下一结点的引用

  - 结构图

    ![](/Users/space/Documents/Package/Note/Core Java/assets/9.2.1链表的结构.png)
    
  - 实现原理

    <!--源码-->

    ```java
    // 结点的Node内部类
    private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;
        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
    ```

    <!--解析-->

    1. 链表的节点使用Node内部类实现
    2. 当前节点的前后节点会在当前节点中的内部类中进行赋值，来实现双向链表。实在是精妙之极，令人赞叹

- 方法

  - add()

  - add(int i , E element)：特定位置添加元素

    <!--源码-->

    1.add方法

    ```java
    public void add(int index, E element) {
            checkPositionIndex(index);
    
            if (index == size)
                linkLast(element);
            else
                linkBefore(element, node(index));
        }
    ```

    2.linkLast——调用的方法

    ```java
    // 把新节点加入到末尾的方法
    void linkLast(E e) {
            final Node<E> l = last;
            final Node<E> newNode = new Node<>(l, e, null); // node构造方法：Node(Node<E> prev, E element, Node<E> next)
            last = newNode;
            if (l == null)
                first = newNode; //如果前一节点为空，则新节点为首个节点
            else
                l.next = newNode; //如果前节点不为空，则前一节点的next值为新节点的引用
            size++;
            modCount++;
        }
    ```

    3.linkBefore——调用的方法

    ```java
    void linkBefore(E e, Node<E> succ) {
            // assert succ != null;
            final Node<E> pred = succ.prev; //获取被添加位置的节点的“前一个节点的引用”，赋值给添加的元素中node类的前一个结点引用的属性
            final Node<E> newNode = new Node<>(pred, e, succ); // 新节点构造
            succ.prev = newNode; // 被添加后，后一个元素的前一个节点引用属性修改为添加的元素的引用
            if (pred == null)
                first = newNode;
            else
                pred.next = newNode;// 被添加后，前一个元素的后一个节点引用属性修改为添加的元素的引用
            size++;
            modCount++;
        }
    ```

    4.node(index)——调用的方法作为传参

    ```java
    Node<E> node(int index) {
            // assert isElementIndex(index);
            if (index < (size >> 1)) {
                Node<E> x = first;
                for (int i = 0; i < index; i++)
                    x = x.next;
                return x;
            } else {
                Node<E> x = last;
                for (int i = size - 1; i > index; i--)
                    x = x.prev;
                return x;
            }
        }
    ```

    <!--解析-->

    1. node(int index)函数，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件index < (size >> 1)，也即是index是靠近前端还是后端。

       <!--比如10个元素，在第2个元素位置插入元素，则将从前往后找，找到第二个元素并传值到linkBefore方法中-->

  - remove(int index)：删除指定位置元素

  - remove(Object o)：删除指定元素（通过equals方法判断）

    <!--源码-->

    ```java
    public boolean remove(Object o) {
            if (o == null) { // 如果为空，则将后面的元素向前移动
                for (Node<E> x = first; x != null; x = x.next) { 
                    if (x.item == null) {
                        unlink(x);
                        return true;
                    }
                }
            } else {
                for (Node<E> x = first; x != null; x = x.next) {
                    if (o.equals(x.item)) {
                        unlink(x);
                        return true;
                    }
                }
            }
            return false;
        }
    ```

    <!--解析-->

    1. 通过equals方法找到需要删除的元素

  - get(int index)：获得指定元素

    <!--源码-->

    ```java
    public E get(int index) {
            checkElementIndex(index);
            return node(index).item;
        }
    ```

  - set(int i , E element)：特定位置新元素替代旧元素

    <!--源码-->

    ```java
    public E set(int index, E element) {
            checkElementIndex(index);
            Node<E> x = node(index);
            E oldVal = x.item; // 将原对象中的值赋值给oldVal变量
            x.item = element;
            return oldVal;
        }
    ```

    <!--解析-->

    1. 将新node对象指向原引用指向的对象，再修改值才能生效
    2. 问题：为什么要返回oldVal，为什么不返回true或者false default

#### 2.ListIterator

- 特点

  - 只有List类能够使用
- 相比于Iterator增加了部分功能
  
- 迭代器定位以及add/remove方法

  - **add方法只依赖迭代器的位置；remove,set方法依赖迭代器的状态**

    原因是：迭代器指向的是元素之间的位置

     <!--要使用remove方法需要存在被越过的数，也就是需要先使用next或者previous方法-->

  - 原理图

  ![](/Users/space/Documents/Package/Note/Core Java/assets/9.2.1链表迭代器定位.png)

### 9.2.2 数组列表

#### 1.ArrayList

- 特点

  - 实现了List接口
  - 非线程安全
  - 顺序容器（元素存放的顺序与放进去的顺序一致），因为底层是数组
  - 容量不足，容器会自动增大底层数组的大小
  - 允许元素为null

- 方法

  - set( )：对指定位置赋值

    <!--源码-->

    ```java
    public E set(int index, E element) {
            Objects.checkIndex(index, size); // 下标越界检查
            E oldValue = elementData(index); // 获取原位置的值
            elementData[index] = element; // 将数组中指定位置的值更新成新值
            return oldValue; // 返回旧值
        }
    ```
  
    <!--解析-->
  
  1. 底层实现是数组，同时无法对在数组外的位置赋值
  
- get( )：获取指定位置的元素
  
  <!--源码-->
  
    ```java
    public E get(int index) {
            Objects.checkIndex(index, size); // 越界检查
            return elementData(index);
        }
  ```
  
  - add( )：向指定位置添加元素
  
    <!--源码-->
  
    ```java
    // 增加的方法
    public void add(int index, E element) {
            rangeCheckForAdd(index); // 是否超过数组大小
            modCount++; // 记录结构性改变的次数
            final int s;
            Object[] elementData;
            if ((s = size) == (elementData = this.elementData).length)
                elementData = grow();
            System.arraycopy(elementData, index,
                             elementData, index + 1,
                             s - index);
            elementData[index] = element;
            size = s + 1;
        }
    ```
  
    ```java
    // 执行add方法前，执行的grow，先增加容量，确保能放入当前添加元素
    private Object[] grow() {
            return grow(size + 1);
        }
    // 执行add方法前，调用newCapacity方法，如果空间不足则扩容
    private int newCapacity(int minCapacity) {
            // overflow-conscious code
            int oldCapacity = elementData.length;
            int newCapacity = oldCapacity + (oldCapacity >> 1); // 原来的1.5倍
            if (newCapacity - minCapacity <= 0) {
                if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                    return Math.max(DEFAULT_CAPACITY, minCapacity);
                if (minCapacity < 0) // overflow
                    throw new OutOfMemoryError();
                return minCapacity;
            }
            return (newCapacity - MAX_ARRAY_SIZE <= 0)
                ? newCapacity
                : hugeCapacity(minCapacity);
        }
    ```
  
    <!--解析-->
  
    1. **modCount的作用是保证安全。ArrayList中的add、remove等方法中，会修改modCount的值，而迭代器是单独线程，运行过程中会检查modCount是否被修改，如果迭代器使用过程中，有其他线程进行了remove、add等操作（也就是修改了modCount值），则将抛出异常ConcurrentModificationException，这就是fail-fast策略。**
  
       **如下，是迭代器的remove源码，在迭代器使用过程中会检查"modCount != expectedModCount"，这时如果其他线程进行了结构性修改，则会报错。——重点**
  
       ```java
       public void remove() {
                   if (current == null)
                       throw new IllegalStateException();
                   if (modCount != expectedModCount) // 检查是否在迭代器使用过程中，有其他线程进行结构性修改
                       throw new ConcurrentModificationException();
                   Object k = current.key;
                   current = null;
                   HashMap.this.removeEntryForKey(k);
                   expectedModCount = modCount;
               }
       ```
  
       <!--错误演示-->
  
       ```java
       List<String> list = new ArrayList<>();
               list.add("A");
               list.add("B");
               list.add("C");
               list.add("D");
       
               for (String s : list) {
                   if (s.equals("B"))
                       list.remove(s); // 在迭代器运行过程中，进行结构性修改后，报错
               }
       /* output
       Exception in thread "main" java.util.ConcurrentModificationException
       */
       ```
  
       <!--正确演示-->
  
       ```java
       List<String> list = new ArrayList<>();
               list.add("A");
               list.add("B");
               list.add("C");
               list.add("D");
               Iterator<String> iterator = list.iterator();
               while (iterator.hasNext()){
                   if (iterator.next().equals("B")){
                       iterator.remove();
                   }
               }
               for (String s : list) {
                   System.out.println(s);
               }
       /* output
       A
       C
       D
       */
       ```
  
       
  
    2. newCapacity执行后，会将原数组复制到新数组，然后再执行add方法
  
  - remove( )：删除元素
  
    <!--源码-->
  
    ```java
    // 删除的方法
    public E remove(int index) {
            Objects.checkIndex(index, size);
            final Object[] es = elementData;
    
            @SuppressWarnings("unchecked") E oldValue = (E) es[index];
            fastRemove(es, index);
    
            return oldValue;
        }
    // 被删除调用的方法，真正执行删除操作的方法
    private void fastRemove(Object[] es, int i) {
            modCount++;
            final int newSize;
            if ((newSize = size - 1) > i)
                System.arraycopy(es, i + 1, es, i, newSize - i);
            es[size = newSize] = null;
        }
    ```
  
    <!--解析-->
  
    1. fastRemove方法中，因为被删除元素后的元素都向前移动一个位置，因此最后的元素需要赋值为null，让GC进行回收处理

#### 2.ArrayList与Vector区别

- Vector是线程安全的集合类，ArrayList并不是线程安全的类。Vector类对集合的元素操作时都加了synchronized，所以方法都是同步的，保证线程安全。
- Vector与ArrayList本质上都是一个Object[] 数组，ArrayList提供了size属性，Vector提供了elementCount属性，他们的作用是记录集合内有效元素的个数。与我们平常调用的arrayList.size()和vector.size()一样返回的集合内有效元素的个数。
- Vector与ArrayList的扩容并不一样，Vector默认扩容是增长一倍的容量，Arraylist是增长50%的容量。
- Vector与ArrayList的remove,add(index,obj)方法都会导致内部数组进行数据拷贝的操作，这样在大数据量时，可能会影响效率。
- Vector与ArrayList的add(obj)方法，如果新增的有效元素个数超过数组本身的长度，都会导致数组进行扩容。

### 9.2.3 散列集

- 散列码 定义：散列表为每个对象计算的一个整数，是由对象的实例域产生的

  <!--比如String的hashCode方法产生散列码-->

- 散列表（也称哈希表） 定义：由链表数组实现。每个列表称为桶

- 规则

  - 查找特定对象方法：计算散列码，散列码与桶的总数取余，结果为对象所在桶的索引

    <!--散列码为777，桶有70个，余数为7，因此对象应该保存在7号桶中-->

  - 插入对象方法：如果桶为空，则直接加入；如果桶已满（也称为散列冲突），需要用新对象与桶中所有对象进行比较，查看是否存在。在Java SE8中，桶满时会从链表变为平衡二叉树。

  - 散列表过满解决方法：再散列。通过设置装填因子（如果设置为0.7，如果表中超过70%位置已经被使用，则将执行再散列）
  
  > 散列冲突如何解决——面试题
  >
  > **1、直接定址法**：取关键字或关键字的某个线性函数值为散列地址。即 Hash(k) = k 或 hash(k) = ak+b，其中 a b为常数（这种散列函数叫做自身函数）
  >
  > **2、数字分析法**：假设关键字是以*r*为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。比如有一组value1=112233，value2=112633，value3=119033，针对这样的数我们分析数中间两个数比较波动，其他数不变。那么我们取key的值就可以是key1=22,key2=26,key3=90。
  >
  > **3、平方中取法**：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。
  >
  > **4、折叠法**：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。举个例子，比如value=135790，要求key是2位数的散列值。那么我们将value变为13+57+90=160，然后去掉高位“1”,此时key=60，这就是他们的哈希关系，这样做的目的就是key与每一位value都相关，来做到“散列地址”尽可能分散的目地。
  >
  > **5、随机数法**
  >
  > **6、除留余数法：**取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址，即hash(k) = k mod p, p <= m。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生冲突。

### 9.2.4 树集

- 特点：类似散列集，但有序

  原因：排序通过树结构实现（红黑树）——default

  <!--任意顺序插入，遍历时，每个值会按照排序后的顺序输出，实现如下-->

  ```java
  public class TestTreeSet {
      public static void main(String[] args) {
          SortedSet<String> sortedSet = new TreeSet<String>();
          sortedSet.add("c");
          sortedSet.add("b");
          sortedSet.add("am");
          for (String s : sortedSet) {
              System.out.println(s);
          }
      }
  }/* output
  am
  b
  c
  */
  ```

- 注意

  - 使用树集，必须能够比较元素。必须实现Comparable接口，或者构造集时提供一个Comparator

    <!--实现：根据Item对象的id值进行排序-->

    ```java
    // Item对象
    public class Item implements Comparable{
        private String name;
        private int id;
    
        Item(String name , int id) {
            this.name = name;
            this.id = id;
        }
    
        @Override public String toString() {
            return "Item{" + "name='" + name + '\'' + ", id=" + id + '}';
        }
    		// 因为需要实现Comparable接口，因此需要重写compareTo方法
        @Override public int compareTo(Object o) {
            Item item = (Item)o;
            return (this.id - item.id) ;
        }
        }
    ```

    ```java
    // 测试类
    public class TestTreeSetSorted {
        public static void main(String[] args) {
            SortedSet<Item> parts = new TreeSet<>();
            parts.add(new Item("Toy", 123));
            parts.add(new Item("Adam", 321));
            parts.add(new Item("Fake", 63));
            System.out.println(parts);
        }
    }
    ```

  - 树集的排序是全序，保证任意元素可比性

- 树集和散列集的取舍

  - 判断是否需要排序：如果需要排序可以选择树集，但是需要考虑排序的难度；不需要排序，则使用散列集，节约排序的开销

### 9.2.5 队列与双端队列

- 规则
  - 支持在头部和尾部同时添加或删除元素
  - 不支持在队列中间添加元素

#### 1.ArrayDeque

- 特点

  - 双端队列，可以作为栈使用，也能作为队列使用

  - 底层为数组实现，并且为循环数组（以实现同时在头部和尾部插入元素）

    <!--源码-->

    ```java
     // 构造方法
     public ArrayDeque() {
            elements = new Object[16 + 1];
        }
    ```

  - 非线程安全

  - 不能插入null值

- 方法

  - add( )：添加元素

    <!--源码-->

    1.add方法

    ```java
    public boolean add(E e) {
            addLast(e);
            return true;
        }
    ```

    2.addLast方法——调用的方法

    ```java
    public void addLast(E e) {
            if (e == null) // 不允许放入null
                throw new NullPointerException();
            final Object[] es = elements;
            es[tail] = e; // 赋值
            if (head == (tail = inc(tail, es.length)))
                grow(1); // 扩容
        }
    ```

  - pollFirst()：删除并返回队首的元素

    <!--源码-->

    1.pollFirst

    ```java
     public E pollFirst() {
            final Object[] es;
            final int h;
            E e = elementAt(es = elements, h = head);  // 获取到头部的元素
            if (e != null) {
                es[h] = null;  // 让GC工作
                head = inc(h, es.length);
            }
            return e;
        }
    ```

    2.elementAt——调用的方法

    ```java
    static final <E> E elementAt(Object[] es, int i) {
            return (E) es[i];
        }
    ```

  - peekFirst( )：返回队首的元素

    <!--源码-->

    1.peekFirst

    ```java
    public E peekFirst() {
            return elementAt(elements, head);
        }
    ```

    2.elementAt——调用的方法

    ```java
    static final <E> E elementAt(Object[] es, int i) {
            return (E) es[i];
        }
    ```

### 9.2.6 优先级队列

- 结构：堆。能够自我调节的二叉树 ——default

- 规则

  - 支持任意顺序插入，按照排序的顺序检索，但并未对所有元素排序 

    <!--调用remove方法，总会获得队列中最小的元素-->

## 9.3 映射

- 映射（map） 定义：存放键/值对的一种数据结构

### 9.3.1 基本映射操作

- 规则

  - 键必须唯一
  - 添加：put( ),必须提供键
  - 检索：get( ),必须使用一个键
  - 替换：put( )，同时会返回被替换的值
  - 删除：remove( )
  - 元素数量统计：size( )

  <!--实现-->

  ```java
  // 方法实现
  public class TestHashMap {
      public static void main(String[] args) {
          // 创建散列映射
          Map<String,Employee> staff = new HashMap<>();
  
          // 添加元素
          staff.put("00-01", new Employee("Toyz1"));
          staff.put("00-04", new Employee("Toyz4"));
          staff.put("00-02", new Employee("Toyz2"));
          staff.put("00-03", new Employee("Toyz3"));
  
          // 输出所有元素
          System.out.println("----输出所有元素");
          System.out.println(staff.toString());
  
          // 删除
          System.out.println("----删除");
          staff.remove("00-01");
          System.out.println(staff.toString());
  
          // 替换
          System.out.println("----替换");
          System.out.println(staff.put("00-02", new Employee("new Toyz")));
          System.out.println(staff.toString());
  
          // 查询
          System.out.println("----查询");
          System.out.println(staff.get("00-02"));
          System.out.println(staff.get("00-12"));
          
          // 遍历输出并统计数量
          System.out.println("----遍历输出并统计数量");
          for (String n : staff.keySet()) {
              System.out.println(n+":"+staff.get(n));
          }
          System.out.println("元素数量为："+staff.size());
      }
  }/* output
  ----输出所有元素
  {00-01=Employee{name='Toyz1'}, 00-02=Employee{name='Toyz2'}, 00-03=Employee{name='Toyz3'}, 00-04=Employee{name='Toyz4'}}
  ----删除
  {00-02=Employee{name='Toyz2'}, 00-03=Employee{name='Toyz3'}, 00-04=Employee{name='Toyz4'}}
  ----替换
  Employee{name='Toyz2'}
  {00-02=Employee{name='new Toyz'}, 00-03=Employee{name='Toyz3'}, 00-04=Employee{name='Toyz4'}}
  ----查询
  Employee{name='new Toyz'}
  null
  ----遍历输出并统计数量
  00-02:Employee{name='new Toyz'}
  00-03:Employee{name='Toyz3'}
  00-04:Employee{name='Toyz4'}
  元素数量为：3
  */
  ```
```
  
  ```java
  // 对象类——unimportant
  public class Employee {
      private String name;
  
      Employee(String name) {
          this.name = name;
      }
  
      @Override public String toString() {
          return "Employee{" + "name='" + name + '\'' + '}';
      }
  }
```


### 9.3.2 更新映射项

- 场景

  统计某个单词C出现频次，更新映射项时，正常情况是根据键取得原值并修改后放回。但是如果键是首次出现，使用get方法获取时，会出现null现象

- 解决方法：

  1. 使用getOrDefault方法
  2. 使用merge方法：如果键原先不存在，则把C和1关联，否则使用sum将原值和1求和

  <!--实现-->

  ```java
  // 场景
  public class TestMerge {
      public static void main(String[] args) {
          Map<String,Integer> map = new HashMap<>();
          map.put("C", map.get("C")+1);
          System.out.println(map.get("C"));
      }
  }/* output
  java.lang.NullPointerException
  */
  ```

  ```java
  // 解决方法
  public class TestMerge {
      public static void main(String[] args) {
          Map<String,Integer> map = new HashMap<>();
          // 解决方法1
          map.put("C", map.getOrDefault("C", 0)+1);
          // 解决方法2
          map.put("C", map.merge("C", 1, Integer::sum));
          System.out.println(map.get("C"));
      }
  }
  ```

##### 补充：双冒号的使用

- 格式：类名::方法名

- 功能：支持将值传入类名中的方法

  <!--实现-->

  ```java
  public class TestDouble {
      private static void printChar(Character characterc){
          System.out.println(characterc);
      }
      public static void main(String[] args) {
          List<Character> list = Arrays.asList('a','b','c');
          // 双冒号用法
          list.forEach(TestDouble::printChar);
          // 普通方法实现
          for (Character c : list) {
              TestDouble.printChar(c);
          }
      }
  }/* output
  a
  b
  c
  a
  b
  c
  */
  
  /* conclusion
  1.使用双冒号能够替换普通方法
  */
  ```

### 9.3.3 映射视图

- 类型

  1. 键集
  2. 值集合
  3. 键/值对集

- 格式

  ```java
  // 1.键集
  Set<K> keySet();
  // 2.值集合
  Collection<V> values();
  // 3.键/值对集
  Set<Map,Entry<K,V>> entrySet();
  ```

  <!--实现：遍历输出三种集-->

  ```java
  public class TestHashMap {
      public static void main(String[] args) {
          // 创建散列映射
          Map<String,Employee> staff = new HashMap<>();
  
          // 添加元素
          staff.put("00-01", new Employee("Toyz1"));
          staff.put("00-02", new Employee("Toyz2"));
          staff.put("00-03", new Employee("Toyz3"));
          staff.put("00-04", new Employee("Toyz4"));
          // 遍历输出
          System.out.println("----遍历输出");
          // 键集视图
          System.out.println("----键集");
          for (String n : staff.keySet()) {
              System.out.println(n);
          }
  
          // 值集合视图
          System.out.println("----值集合");
          for (Employee e : staff.values()) {
              System.out.println(e);
          }
  
          // 键值对集视图
          System.out.println("----键值对集");
          for (Map.Entry<String, Employee> staff1: staff.entrySet()) {
              System.out.println(staff1.getKey());
              System.out.println(staff1.getValue());
          }
      }
  }
  /* output
  ----遍历输出
  ----键集
  00-02
  00-03
  00-04
  ----值集合
  Employee{name='new Toyz'}
  Employee{name='Toyz3'}
  Employee{name='Toyz4'}
  ----键值对集
  00-02
  Employee{name='new Toyz'}
  00-03
  Employee{name='Toyz3'}
  00-04
  Employee{name='Toyz4'}
  */
  ```

### 9.3.4 弱散列映射

- 场景：如果一个值所对应的键不再使用，由于映射对象是活动的，所以其中的所有桶都是活动的，垃圾回收器就无法对其回收

- 解决方法

  - 使用WeakHashMap类

- 原理

  Key继承WeakReference，表示是弱引用，当垃圾回收且不再引用时，就会被回收

  <!--实现-->

  ```java
  public class TestWeakHashMap {
      public static void main(String[] args) {
          String s1 = new String("1");
          String s2 = new String("2");
          // 初始化WeakHashMap
          WeakHashMap<String,Person> weakHashMap = new WeakHashMap<>();
          weakHashMap.put(s1, new Person("A"));
          weakHashMap.put(s2, new Person("B"));
          for (Map.Entry<String,Person>  person: weakHashMap.entrySet()) {
              System.out.println(person);
          }
          // 清除键
          s2 = null;
          // 调用垃圾回收器
          System.gc();
  
          for (Map.Entry<String,Person>  person: weakHashMap.entrySet()) {
              System.out.println(person);
          }
      }
  }/* output
  1=Person{name='A'}
  2=Person{name='B'}
  1=Person{name='A'}
  */
  /* conclusion
  1.PersonB已经被回收
  ```

### 9.3.5 链接散列集与映射

- LinkedHashSet和LinkedHashMap类支持记住插入元素项的顺序

  <!--实现-->

  ```java
  public class TestLinkedHashSet {
      public static void main(String[] args) {
          /*
          链接散列映射
           */
          // 初始化链接散列映射
          Map<String, Person> person = new LinkedHashMap<>();
          person.put("00-01", new Person("One"));
          person.put("00-03", new Person("Three"));
          person.put("00-02", new Person("Two"));
  
          //输出
          for (String s : person.keySet()) {
              System.out.println(s);
          }
  
          /*
          链接散列集
           */
          Set<Person> personSet = new LinkedHashSet<>();
          personSet.add(new Person("Four"));
          personSet.add(new Person("Six"));
          personSet.add(new Person("Five"));
  
          //输出
          for (Person p : personSet) {
              System.out.println(p);
          }
      }
  }
  /* output
  00-01
  00-03
  00-02
  Person{name='Four'}
  Person{name='Six'}
  Person{name='Five'}
  */
  ```

### 9.3.6 枚举集与映射

### 9.3.7 标识散列映射

- 类IdentityHashMap有特殊用途
- 注意
  - 当前类的键的散列值不是使用hashCode函数计算，而是通过System.IdentityHashCode计算（根据对象的内存地址来计算）
  - 两个对象比较时，需要用==，而不是equals
- 用途：实现对象遍历算法（对象串行化）时，用来跟踪每个对象的遍历状况

## 9.4 视图与包装器

- 视图 定义：一个具有限制的集合对象，可能只可以读、无法改变大小、只支持删除不支持插入

- 注意

  - 返回的对象不是集合对象，而是视图对象，带有访问底层数组的set和get方法，但改变数组大小的所有方法（如迭代器中的add和remove方法）都是不允许的

    <!--实现-->

    peoples就是视图对象

    ```java
    public class TestViews {
        public static void main(String[] args) {
            Person[] people = new Person[10];
            List<Person> peoples = Arrays.asList(people);
            peoples.set(2, new Person("toyz"));
            System.out.println(peoples.get(2));
        }
    }
    ```

  - Collection类包含的很多方法，返回值都是集合。不要和Collection接口混淆

### 9.4.2 子范围

- 规则

  - 支持为集合建立子范围视图。

    - 通过元素范围来划定：第一个索引包含在内，第二个索引不包含

      <!--实现：列表staff，取出第10个至19个元素-->

      ```java
      List groups = staff.subList(10,20);
      ```

    - 通过排序顺序来划定

      <!--实现：返回大于等于from，小于to的元素子集-->

      ```java
      SortedMap<E> subMap(K from, K to)
      ```

### 9.4.3 不可修改的视图

- 原理：Collection部分方法，用于产生集合的不可修改视图，这些视图对现有集合增加了运行时检查，如果修改会抛出异常

- 方法

  Collection.unmodifiableCollection：返回的是集合

  Collection.unmodifiableList

  Collection.unmodifiableSet

  Collection.unmodifiableSortedSet

  Collection.unmodifiableNavigableSet

  Collection.unmodifiableMap

  Collection.unmodifiableSortedMap

  Collection.unmodifiableNavifableMap

- 格式

  ```java
  // 获得一个集合的不可修改视图
  List<String> staffList =  Collections.unmodifiableList(staff);
  ```

  <!--实现：验证不可修改-->
  
  ```java
  public class TestUnmodifiableViews {
      public static void main(String[] args) {
          List<String> staff = new LinkedList<>();
          staff.add("A");
          staff.add("B");
          List<String> staffList =  Collections.unmodifiableList(staff);
          staffList.set(1, "DD");
      }
  }
  /* output：抛出异常
  Exception in thread "main" java.lang.UnsupportedOperationException
  */
  ```

### 9.4.4 同步视图

- 同步视图能够保证线程安全 <!--如果一个线程在添加元素，另一个线程正在再散列，会造成线程不安全-->

- 格式

  ```java
  Map<String,Employee> map = Collection.synchronizedMap(new HashMap<String,Employee>())
  ```

### 9.4.5 受查视图

- 场景：错误类型的元素混入泛型集合的问题，在add时无法发现，只有在get时，将结果转化为String时才会报错

- 解决方法：使用受查视图，能够监测到问题

- 格式

  ```java
  List<String> safeString = Collections.checkedList(String,String.class)
  ```

## 9.5 算法

详情见《算法图解》

> 一提到算法大家想到的可能是c语言中各式各样的排序，查找，二分等算法。但是在java集合类库中，并不需要这么麻烦。我们在Collections这个类中实现了几乎所有的简单算法，为了让程序员不会因为每次要实用算法时，都要自己编写一遍而感到苦恼。Collections这个类在上面也多次出现过了，这个类全部都是静态方法，而且它也确实只是在做一些包装性质的工作



















































