# 九.集合

## 9.1 Java集合框架

### 9.1.1 将集合的接口与实现分离

- 特点：java集合类库将接口与实现分离

### 9.1.2 Collection接口

- 简介：集合类的基本接口是Collection接口

- 方法

  ```java
  public interface Collection<E>{
    boolean add(E element); // 添加元素
    Iterator<E> iterator(); // 返回实现Iterator接口的对象，可使用该对象遍历集合中的元素
  }
  ```

### 9.1.3 迭代器

- 方法

  ```java
  public interface Iterator<E>{
    E next(); // 逐个访问元素
    boolean hasNext(); // 判断是否下一个元素是否存在
    void remove(); // 删除刚刚next的元素
    default void forEachRemaining(Consumer< ? super E> action);
  }
  ```

- 注意

  - Java迭代器位于两个元素之间，调用next时，越过下个元素，并返回刚刚越过的元素

    ![](/Users/space/Documents/Package/Note/Core Java/assets/9.迭代器移动指针.jpg)
    
  - next方法和remove方法互相依赖。使用remove前需要先调用next，因此无法连续调用remove方法删除两个相邻的元素。原因如上

### 9.1.5 集合框架中的接口

- 集合基本接口：Collection和Map

## 9.2 具体的集合

- 集合类型表

  | 集合类型        | 描述                                       |
  | --------------- | ------------------------------------------ |
  | ArrayList       | 支持动态增长和缩减的索引序列               |
  | LinkedList      | 支持在任意位置高效插入和删除操作的有序序列 |
  | ArrayDeque      | 使用循环数组实现的双端队列                 |
  | HashSet         | 没有重复元素的无序集合                     |
  | TreeSet         | 有序集                                     |
  | EnumSet         | 包含枚举类型值的集                         |
  | LinkedHashSet   | 支持记住元素插入次序的集                   |
  | PriorityQueue   | 支持高效删除最小元素的集合                 |
  | HashMap         | 存储键/值关联的数据结构                    |
  | TreeMap         | 键值有序排列的映射表                       |
  | EnumMap         | 键值属于枚举类型的映射表                   |
  | LinkedHashMap   | 支持记住键/值项添加次序的映射表            |
  | WeakHashMap     | 其值无用后支持被垃圾回收器回收的映射表     |
  | IdentityHashMap | 用== 而不是equals比较键值的映射表          |

### 9.2.1 链表

- 结构：双向链表

  - 每个结点存放着数据以及上一结点和下一结点的引用

  - 结构图

    ![](/Users/space/Documents/Package/Note/Core Java/assets/9.2.1链表的结构.png)

- API

  - add(int i , E element)：特定位置添加元素
  - set(int i , E element)：特定位置新元素替代旧元素
  - remove(int i)：删除指定位置元素

- 迭代器定位以及add/remove方法

  - 迭代器同样存在add，set，remove方法

  - **add方法只依赖迭代器的位置；remove,set方法依赖迭代器的状态**

    原因是：迭代器指向的是元素之间的位置

     <!--要使用remove方法需要存在被越过的数，也就是需要先使用next或者previous方法-->

  - 原理图

  ![](/Users/space/Documents/Package/Note/Core Java/assets/9.2.1链表迭代器定位.png)

### 9.2.2 数组列表

#### 1.ArrayList与Vector区别

- Vector是线程安全的集合类，ArrayList并不是线程安全的类。Vector类对集合的元素操作时都加了synchronized，所以方法都是同步的，保证线程安全。
- Vector与ArrayList本质上都是一个Object[] 数组，ArrayList提供了size属性，Vector提供了elementCount属性，他们的作用是记录集合内有效元素的个数。与我们平常调用的arrayList.size()和vector.size()一样返回的集合内有效元素的个数。
- Vector与ArrayList的扩容并不一样，Vector默认扩容是增长一倍的容量，Arraylist是增长50%的容量。
- Vector与ArrayList的remove,add(index,obj)方法都会导致内部数组进行数据拷贝的操作，这样在大数据量时，可能会影响效率。
- Vector与ArrayList的add(obj)方法，如果新增的有效元素个数超过数组本身的长度，都会导致数组进行扩容。

### 9.2.3 散列集

- 散列码 定义：散列表为每个对象计算的一个整数，是由对象的实例域产生的

  <!--比如String的hashCode方法产生散列码-->

- 散列表（也称哈希表） 定义：由链表数组实现。每个列表称为桶

- 规则

  - 查找特定对象方法：计算散列码，散列码与桶的总数取余，结果为对象所在桶的索引

    <!--散列码为777，桶有70个，余数为7，因此对象应该保存在7号桶中-->

  - 插入对象方法：如果桶为空，则直接加入；如果桶已满（也称为散列冲突），需要用新对象与桶中所有对象进行比较，查看是否存在。在Java SE8中，桶满时会从链表变为平衡二叉树。

  - 散列表过满解决方法：再散列。通过设置装填因子（如果设置为0.7，如果表中超过70%位置已经被使用，则将执行再散列）
  
  > 散列冲突如何解决——面试题
  >
  > **1、直接定址法**：取关键字或关键字的某个线性函数值为散列地址。即 Hash(k) = k 或 hash(k) = ak+b，其中 a b为常数（这种散列函数叫做自身函数）
  >
  > **2、数字分析法**：假设关键字是以*r*为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。比如有一组value1=112233，value2=112633，value3=119033，针对这样的数我们分析数中间两个数比较波动，其他数不变。那么我们取key的值就可以是key1=22,key2=26,key3=90。
  >
  > **3、平方中取法**：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。
  >
  > **4、折叠法**：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。举个例子，比如value=135790，要求key是2位数的散列值。那么我们将value变为13+57+90=160，然后去掉高位“1”,此时key=60，这就是他们的哈希关系，这样做的目的就是key与每一位value都相关，来做到“散列地址”尽可能分散的目地。
  >
  > **5、随机数法**
  >
  > **6、除留余数法：**取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址，即hash(k) = k mod p, p <= m。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生冲突。

### 9.2.4 树集

- 特点：类似散列集，但有序

  原因：排序通过树结构实现（红黑树）——default

  <!--任意顺序插入，遍历时，每个值会按照排序后的顺序输出，实现如下-->

  ```java
  public class TestTreeSet {
      public static void main(String[] args) {
          SortedSet<String> sortedSet = new TreeSet<String>();
          sortedSet.add("c");
          sortedSet.add("b");
          sortedSet.add("am");
          for (String s : sortedSet) {
              System.out.println(s);
          }
      }
  }/* output
  am
  b
  c
  */
  ```

- 注意

  - 使用树集，必须能够比较元素。必须实现Comparable接口，或者构造集时提供一个Comparator

    <!--实现：根据Item对象的id值进行排序-->

    ```java
    // Item对象
    public class Item implements Comparable{
        private String name;
        private int id;
    
        Item(String name , int id) {
            this.name = name;
            this.id = id;
        }
    
        @Override public String toString() {
            return "Item{" + "name='" + name + '\'' + ", id=" + id + '}';
        }
    		// 因为需要实现Comparable接口，因此需要重写compareTo方法
        @Override public int compareTo(Object o) {
            Item item = (Item)o;
            return (this.id - item.id) ;
        }
        }
    ```

    ```java
    // 测试类
    public class TestTreeSetSorted {
        public static void main(String[] args) {
            SortedSet<Item> parts = new TreeSet<>();
            parts.add(new Item("Toy", 123));
            parts.add(new Item("Adam", 321));
            parts.add(new Item("Fake", 63));
            System.out.println(parts);
        }
    }
    ```

  - 树集的排序是全序，保证任意元素可比性

- 树集和散列集的取舍

  - 判断是否需要排序：如果需要排序可以选择树集，但是需要考虑排序的难度；不需要排序，则使用散列集，节约排序的开销

### 9.2.5 队列与双端队列

- 规则
  - 支持在头部和尾部同时添加或删除元素
  - 不支持在队列中间添加元素

### 9.2.6 优先级队列

- 结构：堆。能够自我调节的二叉树 ——default

- 规则

  - 支持任意顺序插入，按照排序的顺序检索，但并未对所有元素排序 

    <!--调用remove方法，总会获得队列中最小的元素-->

## 9.3 映射

- 映射（map） 定义：存放键/值对的一种数据结构

### 9.3.1 基本映射操作

- 规则

  - 键必须唯一
  - 添加：put( ),必须提供键
  - 检索：get( ),必须使用一个键
  - 替换：put( )
  - 删除：remove( )
  - 元素数量统计：size( )

  <!--实现-->

  ```java
  // 方法实现
  public class TestHashMap {
      public static void main(String[] args) {
          // 创建散列映射
          Map<String,Employee> staff = new HashMap<>();
  
          // 添加元素
          staff.put("00-01", new Employee("Toyz1"));
          staff.put("00-04", new Employee("Toyz4"));
          staff.put("00-02", new Employee("Toyz2"));
          staff.put("00-03", new Employee("Toyz3"));
  
          // 输出所有元素
          System.out.println("----输出所有元素");
          System.out.println(staff.toString());
  
          // 删除
          System.out.println("----删除");
          staff.remove("00-01");
          System.out.println(staff.toString());
  
          // 替换
          System.out.println("----替换");
          staff.put("00-02", new Employee("new Toyz"));
          System.out.println(staff.toString());
  
          // 查询
          System.out.println("----查询");
          System.out.println(staff.get("00-02"));
          System.out.println(staff.get("00-12"));
          
          // 遍历输出并统计数量
          System.out.println("----遍历输出并统计数量");
          for (String n : staff.keySet()) {
              System.out.println(n+":"+staff.get(n));
          }
          System.out.println("元素数量为："+staff.size());
      }
  }/* output
  ----输出所有元素
  {00-01=Employee{name='Toyz1'}, 00-02=Employee{name='Toyz2'}, 00-03=Employee{name='Toyz3'}, 00-04=Employee{name='Toyz4'}}
  ----删除
  {00-02=Employee{name='Toyz2'}, 00-03=Employee{name='Toyz3'}, 00-04=Employee{name='Toyz4'}}
  ----替换
  {00-02=Employee{name='new Toyz'}, 00-03=Employee{name='Toyz3'}, 00-04=Employee{name='Toyz4'}}
  ----查询
  Employee{name='new Toyz'}
  null
  ----遍历输出并统计数量
  00-02:Employee{name='new Toyz'}
  00-03:Employee{name='Toyz3'}
  00-04:Employee{name='Toyz4'}
  元素数量为：3
  */
  ```

  ```java
  // 对象类——unimportant
  public class Employee {
      private String name;
  
      Employee(String name) {
          this.name = name;
      }
  
      @Override public String toString() {
          return "Employee{" + "name='" + name + '\'' + '}';
      }
  }
  ```

  



















