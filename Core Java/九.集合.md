# 九.集合

## 9.1 Java集合框架

### 9.1.1 将集合的接口与实现分离

- 特点：java集合类库将接口与实现分离

- 集合分类
  - Set代表无序、不可重复的集合
  - List代表有序、重复的集合
  - Map则代表具有映射关系的集合
  - Queue体系集合，代表一种队列集合实现
  
- 各类的特点

  ![](/Users/space/Documents/Package/Note/Core Java/assets/9.2集合框架特点.jpg)

### 9.1.2 Collection接口

- 简介：集合类的基本接口是Collection接口

- 方法

  ```java
  public interface Collection<E>{
    boolean add(E element); // 添加元素
    Iterator<E> iterator(); // 返回实现Iterator接口的对象，可使用该对象遍历集合中的元素
  }
  ```
  
- 接口继承树

  <!--Map接口没有继承自Collection接口，因为Map表示的是关联式容器而不是集合-->
  
  ![](/Users/space/Documents/Package/Note/Core Java/assets/9.3Collection接口继承.png)

### 9.1.3 迭代器

- 方法

  ```java
  public interface Iterator<E>{
    E next(); // 逐个访问元素
    boolean hasNext(); // 判断是否下一个元素是否存在
    void remove(); // 删除刚刚next的元素
    default void forEachRemaining(Consumer< ? super E> action);
  }
  ```

- 用途：提供遍历容器中元素的方法

  <!--实现：使用迭代器和for-each遍历输出，for-each底层实现为迭代器-->

  ```java
  public class TestIterator {
      public static void main(String[] args) {
          List<String> list = new ArrayList<>();
          list.add("A");
          list.add("B");
          list.add("C");
          // 迭代器实现遍历
          Iterator<String> iterator = list.iterator();
          while (iterator.hasNext()){
              System.out.println(iterator.next());
          }
          // for-each实现遍历
          for (String s : list) {
              System.out.println(s);
          }
      }
  }
  ```
  
  
  
- 注意

  - Java迭代器位于两个元素之间，调用next时，越过下个元素，并返回刚刚越过的元素

    ![](/Users/space/Documents/Package/Note/Core Java/assets/9.迭代器移动指针.jpg)
    
  - next方法和remove方法互相依赖。使用remove前需要先调用next，因此无法连续调用remove方法删除两个相邻的元素。原因如上

### 9.1.5 集合框架中的接口

- 集合基本接口：Collection和Map

## 9.2 具体的集合

- 集合类型表

  | 集合类型        | 描述                                       |
  | --------------- | ------------------------------------------ |
  | ArrayList       | 支持动态增长和缩减的索引序列               |
  | LinkedList      | 支持在任意位置高效插入和删除操作的有序序列 |
  | ArrayDeque      | 使用循环数组实现的双端队列                 |
  | HashSet         | 没有重复元素的无序集合                     |
  | TreeSet         | 有序集                                     |
  | EnumSet         | 包含枚举类型值的集                         |
  | LinkedHashSet   | 支持记住元素插入次序的集                   |
  | PriorityQueue   | 支持高效删除最小元素的集合                 |
  | HashMap         | 存储键/值关联的数据结构                    |
  | TreeMap         | 键值有序排列的映射表                       |
  | EnumMap         | 键值属于枚举类型的映射表                   |
  | LinkedHashMap   | 支持记住键/值项添加次序的映射表            |
  | WeakHashMap     | 其值无用后支持被垃圾回收器回收的映射表     |
  | IdentityHashMap | 用== 而不是equals比较键值的映射表          |

### 9.2.1 链表

- 结构：双向链表

  - 每个结点存放着数据以及上一结点和下一结点的引用

  - 结构图

    ![](/Users/space/Documents/Package/Note/Core Java/assets/9.2.1链表的结构.png)

- API

  - add(int i , E element)：特定位置添加元素
  - set(int i , E element)：特定位置新元素替代旧元素
  - remove(int i)：删除指定位置元素

- 迭代器定位以及add/remove方法

  - 迭代器同样存在add，set，remove方法

  - **add方法只依赖迭代器的位置；remove,set方法依赖迭代器的状态**

    原因是：迭代器指向的是元素之间的位置

     <!--要使用remove方法需要存在被越过的数，也就是需要先使用next或者previous方法-->

  - 原理图

  ![](/Users/space/Documents/Package/Note/Core Java/assets/9.2.1链表迭代器定位.png)

### 9.2.2 数组列表

#### 1.ArrayList

- ArrayList 定义：实现了List接口，是顺序容器（元素存放的顺序与放进去的顺序一致），允许放入null，底层通过数组实现

- 注意

  - 线程不安全
  - 容量不足，容器会自动增大底层数组的大小

- 方法

  - set( )：对指定位置赋值

    <!--源码-->

    ```java
    public E set(int index, E element) {
            Objects.checkIndex(index, size); // 下标越界检查
            E oldValue = elementData(index); // 获取原位置的值
            elementData[index] = element; // 将数组中指定位置的值更新成新值
            return oldValue; // 返回旧值
        }
    /*
    1.底层实现是数组，同时无法对在数组外的位置赋值
    */
    ```

    

#### 2.ArrayList与Vector区别

- Vector是线程安全的集合类，ArrayList并不是线程安全的类。Vector类对集合的元素操作时都加了synchronized，所以方法都是同步的，保证线程安全。
- Vector与ArrayList本质上都是一个Object[] 数组，ArrayList提供了size属性，Vector提供了elementCount属性，他们的作用是记录集合内有效元素的个数。与我们平常调用的arrayList.size()和vector.size()一样返回的集合内有效元素的个数。
- Vector与ArrayList的扩容并不一样，Vector默认扩容是增长一倍的容量，Arraylist是增长50%的容量。
- Vector与ArrayList的remove,add(index,obj)方法都会导致内部数组进行数据拷贝的操作，这样在大数据量时，可能会影响效率。
- Vector与ArrayList的add(obj)方法，如果新增的有效元素个数超过数组本身的长度，都会导致数组进行扩容。

### 9.2.3 散列集

- 散列码 定义：散列表为每个对象计算的一个整数，是由对象的实例域产生的

  <!--比如String的hashCode方法产生散列码-->

- 散列表（也称哈希表） 定义：由链表数组实现。每个列表称为桶

- 规则

  - 查找特定对象方法：计算散列码，散列码与桶的总数取余，结果为对象所在桶的索引

    <!--散列码为777，桶有70个，余数为7，因此对象应该保存在7号桶中-->

  - 插入对象方法：如果桶为空，则直接加入；如果桶已满（也称为散列冲突），需要用新对象与桶中所有对象进行比较，查看是否存在。在Java SE8中，桶满时会从链表变为平衡二叉树。

  - 散列表过满解决方法：再散列。通过设置装填因子（如果设置为0.7，如果表中超过70%位置已经被使用，则将执行再散列）
  
  > 散列冲突如何解决——面试题
  >
  > **1、直接定址法**：取关键字或关键字的某个线性函数值为散列地址。即 Hash(k) = k 或 hash(k) = ak+b，其中 a b为常数（这种散列函数叫做自身函数）
  >
  > **2、数字分析法**：假设关键字是以*r*为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。比如有一组value1=112233，value2=112633，value3=119033，针对这样的数我们分析数中间两个数比较波动，其他数不变。那么我们取key的值就可以是key1=22,key2=26,key3=90。
  >
  > **3、平方中取法**：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。
  >
  > **4、折叠法**：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。举个例子，比如value=135790，要求key是2位数的散列值。那么我们将value变为13+57+90=160，然后去掉高位“1”,此时key=60，这就是他们的哈希关系，这样做的目的就是key与每一位value都相关，来做到“散列地址”尽可能分散的目地。
  >
  > **5、随机数法**
  >
  > **6、除留余数法：**取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址，即hash(k) = k mod p, p <= m。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生冲突。

### 9.2.4 树集

- 特点：类似散列集，但有序

  原因：排序通过树结构实现（红黑树）——default

  <!--任意顺序插入，遍历时，每个值会按照排序后的顺序输出，实现如下-->

  ```java
  public class TestTreeSet {
      public static void main(String[] args) {
          SortedSet<String> sortedSet = new TreeSet<String>();
          sortedSet.add("c");
          sortedSet.add("b");
          sortedSet.add("am");
          for (String s : sortedSet) {
              System.out.println(s);
          }
      }
  }/* output
  am
  b
  c
  */
  ```

- 注意

  - 使用树集，必须能够比较元素。必须实现Comparable接口，或者构造集时提供一个Comparator

    <!--实现：根据Item对象的id值进行排序-->

    ```java
    // Item对象
    public class Item implements Comparable{
        private String name;
        private int id;
    
        Item(String name , int id) {
            this.name = name;
            this.id = id;
        }
    
        @Override public String toString() {
            return "Item{" + "name='" + name + '\'' + ", id=" + id + '}';
        }
    		// 因为需要实现Comparable接口，因此需要重写compareTo方法
        @Override public int compareTo(Object o) {
            Item item = (Item)o;
            return (this.id - item.id) ;
        }
        }
    ```

    ```java
    // 测试类
    public class TestTreeSetSorted {
        public static void main(String[] args) {
            SortedSet<Item> parts = new TreeSet<>();
            parts.add(new Item("Toy", 123));
            parts.add(new Item("Adam", 321));
            parts.add(new Item("Fake", 63));
            System.out.println(parts);
        }
    }
    ```

  - 树集的排序是全序，保证任意元素可比性

- 树集和散列集的取舍

  - 判断是否需要排序：如果需要排序可以选择树集，但是需要考虑排序的难度；不需要排序，则使用散列集，节约排序的开销

### 9.2.5 队列与双端队列

- 规则
  - 支持在头部和尾部同时添加或删除元素
  - 不支持在队列中间添加元素

### 9.2.6 优先级队列

- 结构：堆。能够自我调节的二叉树 ——default

- 规则

  - 支持任意顺序插入，按照排序的顺序检索，但并未对所有元素排序 

    <!--调用remove方法，总会获得队列中最小的元素-->

## 9.3 映射

- 映射（map） 定义：存放键/值对的一种数据结构

### 9.3.1 基本映射操作

- 规则

  - 键必须唯一
  - 添加：put( ),必须提供键
  - 检索：get( ),必须使用一个键
  - 替换：put( )，同时会返回被替换的值
  - 删除：remove( )
  - 元素数量统计：size( )

  <!--实现-->

  ```java
  // 方法实现
  public class TestHashMap {
      public static void main(String[] args) {
          // 创建散列映射
          Map<String,Employee> staff = new HashMap<>();
  
          // 添加元素
          staff.put("00-01", new Employee("Toyz1"));
          staff.put("00-04", new Employee("Toyz4"));
          staff.put("00-02", new Employee("Toyz2"));
          staff.put("00-03", new Employee("Toyz3"));
  
          // 输出所有元素
          System.out.println("----输出所有元素");
          System.out.println(staff.toString());
  
          // 删除
          System.out.println("----删除");
          staff.remove("00-01");
          System.out.println(staff.toString());
  
          // 替换
          System.out.println("----替换");
          System.out.println(staff.put("00-02", new Employee("new Toyz")));
          System.out.println(staff.toString());
  
          // 查询
          System.out.println("----查询");
          System.out.println(staff.get("00-02"));
          System.out.println(staff.get("00-12"));
          
          // 遍历输出并统计数量
          System.out.println("----遍历输出并统计数量");
          for (String n : staff.keySet()) {
              System.out.println(n+":"+staff.get(n));
          }
          System.out.println("元素数量为："+staff.size());
      }
  }/* output
  ----输出所有元素
  {00-01=Employee{name='Toyz1'}, 00-02=Employee{name='Toyz2'}, 00-03=Employee{name='Toyz3'}, 00-04=Employee{name='Toyz4'}}
  ----删除
  {00-02=Employee{name='Toyz2'}, 00-03=Employee{name='Toyz3'}, 00-04=Employee{name='Toyz4'}}
  ----替换
  Employee{name='Toyz2'}
  {00-02=Employee{name='new Toyz'}, 00-03=Employee{name='Toyz3'}, 00-04=Employee{name='Toyz4'}}
  ----查询
  Employee{name='new Toyz'}
  null
  ----遍历输出并统计数量
  00-02:Employee{name='new Toyz'}
  00-03:Employee{name='Toyz3'}
  00-04:Employee{name='Toyz4'}
  元素数量为：3
  */
  ```
```
  
  ```java
  // 对象类——unimportant
  public class Employee {
      private String name;
  
      Employee(String name) {
          this.name = name;
      }
  
      @Override public String toString() {
          return "Employee{" + "name='" + name + '\'' + '}';
      }
  }
```


### 9.3.2 更新映射项

- 场景

  统计某个单词C出现频次，更新映射项时，正常情况是根据键取得原值并修改后放回。但是如果键是首次出现，使用get方法获取时，会出现null现象

- 解决方法：

  1. 使用getOrDefault方法
  2. 使用merge方法：如果键原先不存在，则把C和1关联，否则使用sum将原值和1求和

  <!--实现-->

  ```java
  // 场景
  public class TestMerge {
      public static void main(String[] args) {
          Map<String,Integer> map = new HashMap<>();
          map.put("C", map.get("C")+1);
          System.out.println(map.get("C"));
      }
  }/* output
  java.lang.NullPointerException
  */
  ```

  ```java
  // 解决方法
  public class TestMerge {
      public static void main(String[] args) {
          Map<String,Integer> map = new HashMap<>();
          // 解决方法1
          map.put("C", map.getOrDefault("C", 0)+1);
          // 解决方法2
          map.put("C", map.merge("C", 1, Integer::sum));
          System.out.println(map.get("C"));
      }
  }
  ```

##### 补充：双冒号的使用

- 格式：类名::方法名

- 功能：支持将值传入类名中的方法

  <!--实现-->

  ```java
  public class TestDouble {
      private static void printChar(Character characterc){
          System.out.println(characterc);
      }
      public static void main(String[] args) {
          List<Character> list = Arrays.asList('a','b','c');
          // 双冒号用法
          list.forEach(TestDouble::printChar);
          // 普通方法实现
          for (Character c : list) {
              TestDouble.printChar(c);
          }
      }
  }/* output
  a
  b
  c
  a
  b
  c
  */
  
  /* conclusion
  1.使用双冒号能够替换普通方法
  */
  ```

### 9.3.3 映射视图

- 类型

  1. 键集
  2. 值集合
  3. 键/值对集

- 格式

  ```java
  // 1.键集
  Set<K> keySet();
  // 2.值集合
  Collection<V> values();
  // 3.键/值对集
  Set<Map,Entry<K,V>> entrySet();
  ```

  <!--实现：遍历输出三种集-->

  ```java
  public class TestHashMap {
      public static void main(String[] args) {
          // 创建散列映射
          Map<String,Employee> staff = new HashMap<>();
  
          // 添加元素
          staff.put("00-01", new Employee("Toyz1"));
          staff.put("00-02", new Employee("Toyz2"));
          staff.put("00-03", new Employee("Toyz3"));
          staff.put("00-04", new Employee("Toyz4"));
          // 遍历输出
          System.out.println("----遍历输出");
          // 键集视图
          System.out.println("----键集");
          for (String n : staff.keySet()) {
              System.out.println(n);
          }
  
          // 值集合视图
          System.out.println("----值集合");
          for (Employee e : staff.values()) {
              System.out.println(e);
          }
  
          // 键值对集视图
          System.out.println("----键值对集");
          for (Map.Entry<String, Employee> staff1: staff.entrySet()) {
              System.out.println(staff1.getKey());
              System.out.println(staff1.getValue());
          }
      }
  }
  /* output
  ----遍历输出
  ----键集
  00-02
  00-03
  00-04
  ----值集合
  Employee{name='new Toyz'}
  Employee{name='Toyz3'}
  Employee{name='Toyz4'}
  ----键值对集
  00-02
  Employee{name='new Toyz'}
  00-03
  Employee{name='Toyz3'}
  00-04
  Employee{name='Toyz4'}
  */
  ```

### 9.3.4 弱散列映射

- 场景：如果一个值所对应的键不再使用，由于映射对象是活动的，所以其中的所有桶都是活动的，垃圾回收器就无法对其回收

- 解决方法

  - 使用WeakHashMap类

- 原理

  Key继承WeakReference，表示是弱引用，当垃圾回收且不再引用时，就会被回收

  <!--实现-->

  ```java
  public class TestWeakHashMap {
      public static void main(String[] args) {
          String s1 = new String("1");
          String s2 = new String("2");
          // 初始化WeakHashMap
          WeakHashMap<String,Person> weakHashMap = new WeakHashMap<>();
          weakHashMap.put(s1, new Person("A"));
          weakHashMap.put(s2, new Person("B"));
          for (Map.Entry<String,Person>  person: weakHashMap.entrySet()) {
              System.out.println(person);
          }
          // 清除键
          s2 = null;
          // 调用垃圾回收器
          System.gc();
  
          for (Map.Entry<String,Person>  person: weakHashMap.entrySet()) {
              System.out.println(person);
          }
      }
  }/* output
  1=Person{name='A'}
  2=Person{name='B'}
  1=Person{name='A'}
  */
  /* conclusion
  1.PersonB已经被回收
  ```

### 9.3.5 链接散列集与映射

- LinkedHashSet和LinkedHashMap类支持记住插入元素项的顺序

  <!--实现-->

  ```java
  public class TestLinkedHashSet {
      public static void main(String[] args) {
          /*
          链接散列映射
           */
          // 初始化链接散列映射
          Map<String, Person> person = new LinkedHashMap<>();
          person.put("00-01", new Person("One"));
          person.put("00-03", new Person("Three"));
          person.put("00-02", new Person("Two"));
  
          //输出
          for (String s : person.keySet()) {
              System.out.println(s);
          }
  
          /*
          链接散列集
           */
          Set<Person> personSet = new LinkedHashSet<>();
          personSet.add(new Person("Four"));
          personSet.add(new Person("Six"));
          personSet.add(new Person("Five"));
  
          //输出
          for (Person p : personSet) {
              System.out.println(p);
          }
      }
  }
  /* output
  00-01
  00-03
  00-02
  Person{name='Four'}
  Person{name='Six'}
  Person{name='Five'}
  */
  ```

### 9.3.6 枚举集与映射

### 9.3.7 标识散列映射

- 类IdentityHashMap有特殊用途
- 注意
  - 当前类的键的散列值不是使用hashCode函数计算，而是通过System.IdentityHashCode计算（根据对象的内存地址来计算）
  - 两个对象比较时，需要用==，而不是equals
- 用途：实现对象遍历算法（对象串行化）时，用来跟踪每个对象的遍历状况

## 9.4 视图与包装器

- 视图 定义：一个具有限制的集合对象，可能只可以读、无法改变大小、只支持删除不支持插入

- 注意

  - 返回的对象不是集合对象，而是视图对象，带有访问底层数组的set和get方法，但改变数组大小的所有方法（如迭代器中的add和remove方法）都是不允许的

    <!--实现-->

    peoples就是视图对象

    ```java
    public class TestViews {
        public static void main(String[] args) {
            Person[] people = new Person[10];
            List<Person> peoples = Arrays.asList(people);
            peoples.set(2, new Person("toyz"));
            System.out.println(peoples.get(2));
        }
    }
    ```

  - Collection类包含的很多方法，返回值都是集合。不要和Collection接口混淆

### 9.4.2 子范围

- 规则

  - 支持为集合建立子范围视图。

    - 通过元素范围来划定：第一个索引包含在内，第二个索引不包含

      <!--实现：列表staff，取出第10个至19个元素-->

      ```java
      List groups = staff.subList(10,20);
      ```

    - 通过排序顺序来划定

      <!--实现：返回大于等于from，小于to的元素子集-->

      ```java
      SortedMap<E> subMap(K from, K to)
      ```

### 9.4.3 不可修改的视图

- 原理：Collection部分方法，用于产生集合的不可修改视图，这些视图对现有集合增加了运行时检查，如果修改会抛出异常

- 方法

  Collection.unmodifiableCollection：返回的是集合

  Collection.unmodifiableList

  Collection.unmodifiableSet

  Collection.unmodifiableSortedSet

  Collection.unmodifiableNavigableSet

  Collection.unmodifiableMap

  Collection.unmodifiableSortedMap

  Collection.unmodifiableNavifableMap

- 格式

  ```java
  // 获得一个集合的不可修改视图
  List<String> staffList =  Collections.unmodifiableList(staff);
  ```

  <!--实现：验证不可修改-->
  
  ```java
  public class TestUnmodifiableViews {
      public static void main(String[] args) {
          List<String> staff = new LinkedList<>();
          staff.add("A");
          staff.add("B");
          List<String> staffList =  Collections.unmodifiableList(staff);
          staffList.set(1, "DD");
      }
  }
  /* output：抛出异常
  Exception in thread "main" java.lang.UnsupportedOperationException
  */
  ```

### 9.4.4 同步视图

- 同步视图能够保证线程安全 <!--如果一个线程在添加元素，另一个线程正在再散列，会造成线程不安全-->

- 格式

  ```java
  Map<String,Employee> map = Collection.synchronizedMap(new HashMap<String,Employee>())
  ```

### 9.4.5 受查视图

- 场景：错误类型的元素混入泛型集合的问题，在add时无法发现，只有在get时，将结果转化为String时才会报错

- 解决方法：使用受查视图，能够监测到问题

- 格式

  ```java
  List<String> safeString = Collections.checkedList(String,String.class)
  ```

## 9.5 算法

详情见《算法图解》

> 一提到算法大家想到的可能是c语言中各式各样的排序，查找，二分等算法。但是在java集合类库中，并不需要这么麻烦。我们在Collections这个类中实现了几乎所有的简单算法，为了让程序员不会因为每次要实用算法时，都要自己编写一遍而感到苦恼。Collections这个类在上面也多次出现过了，这个类全部都是静态方法，而且它也确实只是在做一些包装性质的工作



















































