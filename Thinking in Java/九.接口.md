# 9.接口

## 9.1 抽象类和抽象方法

- 抽象类：包含抽象方法的类，自身无法实例化 <!--属于接口和普通类的中间形态-->

- 抽象方法：仅有声明，没有方法体

- 关系：抽象方法是抽象类的充分不必要条件，因此抽象类中允许方法实现和抽象方法同时存在

- 语法

  ```java
  // 抽象类
  abstract class ClassName{}
  
  // 抽象方法
  abstract void f()
  ```

- 注意点
  
  - 抽象类中接入接口，则继承抽象类的导出类同样需要实现接口

## 9.2 接口

- 接口：完全抽象的类
- 规则
  - 使用interface关键字来替代class
  - 访问修饰符只允许public或者默认的包访问权限
  - 只允许方法名、参数列表、返回类型
  - 方法类型默认固定是public
  - 接口可以指向实现该接口的对象
- 用途
  - 建立类与类之间的联系

<!--接口类型可以使用包权限，但是方法默认为public-->

### 9.2.1 接口和抽象类的使用原因——重点

> 抽象类是抽象若干个类的共同点并用来继承，接口是在导出类中增加导出类需要的特殊方法

#### 1.问答

1. 使用接口和抽象类的原因

   > 依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 

   - **实现多态**     <!--如果Farmer需要喂养动物，则只需要传递信息给Animal接口即可，具体喂养的类由多态实现-->

2. 使用接口或抽象类的原因

   - 接口
     - **降低程序模块的耦合**    <!--继承增加模块耦合-->
     - 需要实现的方法不是基类必要属性      <!--比如猴子Smell方法不是哺乳动物的必要属性，而猴子已经继承了哺乳动物抽象类，因此通过接口实现-->
     - 作为单继承的补充
   - 抽象类
     - **复用**   <!--比如猴子和大象都是哺乳动物，有eat(),drink()方法，所以可以抽象出来-->

- 接口和抽象类的异同

  ![](/Users/toyz/Package/Note/Thinking in Java/assets/接口和抽象类的异同.png)

## 9.3 完全解耦

#### 1.策略设计模式

- 定义：一个能够根据传递的参数对象的不同而具有不同行为的方法。
- 策略：传入的参数对象

#### 2.适配器设计模式

- 定义：通过适配器类将接受接口，并返回需要的接口
- 分类：类的适配器、对象的适配器

- 类的适配器
  1. 



