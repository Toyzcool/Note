# 8.多态

> 有继承才有多态

- 定义：分离做什么和怎么做，将改变的事物和不变的事物分离开 <!--存在基类和与基类通讯的方法，即使新增多个导出类，导出类各种变化，与基类通讯的方法在接受导出类时依旧正常运行-->
- 用途：消除类型之间的耦合关系

## 8.1 向上转型

> 对象既可以作为自身使用，也能够作为它的基类对象使用
>
> 向上转型可能会缩小接口，但是不会窄于基类的全部接口

### 8.1.1 忘记对象类型

- 忘记对象类型：**如果一个方法接收基类对象，那这个方法也能接收基类的导出类的对象——重点**

- 用途：降低代码的冗余 <!--比如一个方法能接收基类对象，所以基类导出类的对象都能被该方法接收，而不需要为每个基类导出类重写这个方法-->

- 实现

  <!--基类-->

  ```java
  // 基类
  public class Cycle {
      protected String name;
      public Cycle() {
          this.name = "Cycle";
      }
  }
  ```

  <!--导出类-->

  ```java
  // 导出类
  public class Tricycle extends Cycle{
      public Tricycle() {
          this.name = "Tricycle";
      }
  }
  ```

  <!--向上转型及测试类-->

  ```java
  public class Test {
      static void ride(Cycle cycle){
          System.out.println(cycle.name);
      }
  
      public static void main(String[] args) {
          // 向上转型
          Cycle cycle = new Tricycle();
          ride(cycle);
      }
  }/* output
  Tricycle
  */
  ```

  

## 8.2

### 8.2.1 方法调用绑定

- 绑定：方法调用(对象.方法名)和方法主体(方法的实现)之间关联
- 分类
  - 前期绑定：在程序运行前绑定。java中的static和final符合
  - 后期绑定（动态绑定）：在运行时绑定。除java中的static和final方法(private方法属于隐式final)

### 8.2.2 产生正确的行为

> Java中的所有方法都是通过动态绑定来实现多态，因此编写只与基类交互的方法，导出类都可以运行

### 8.2.3 可扩展性

> 设计良好的OOP程序，大多数方法都会遵循与基类通讯的规则，以保持良好的可扩展性

### 8.2.4 缺陷：“覆盖”私有方法

- 注意点

  因为私有方法无法被覆盖，所以导出类中存在“覆盖”基类中的private方法将会失败而作为新的方法。因此在导出类中，对基类的private方法，最好不重名

### 8.2.5 缺陷：域与静态方法

- 注意点

  **静态方法是和类关联，而不是和单个对象，因此静态方法无法表现出多态**

- 实现

  <!--基类-->

  ```java
  // base class -StaticSub
  public class StaticSuper {
      static String staticGet(){
          return "Super staticGet";
      }
      String dynamicGet(){
          return "Super dynamicGet";
      }
  }
  ```

  <!--导出类-->

  ```java
  public class StaticSub extends StaticSuper {
      static String staticGet(){
          return "Sub staticGet";
      }
      String dynamicGet(){
          return "Sub dynamicGet";
      }
  }
  ```

  <!--测试类-->

  ```java
  public class TestS {
      public static void main(String[] args) {
          StaticSuper staticSuper = new StaticSub();
        	// 打印动态方法返回值
          print(staticSuper.dynamicGet());
          // 打印静态方法返回值
          print(staticSuper.staticGet());
      }
  }/* output
  Sub dynamicGet
  Super staticGet
  */
  ```

## 8.3 构造器和多态

> 构造器实际上是static方法，隐式

### 8.3.1 构造器的调用顺序

1. **调用基类构造器：反复递归，直到层次结构的根**
2. **按照声明顺序调用成员的初始化方法**
3. **调用导出类构造器主体**

### 8.3.2 继承和清理











