# 8.多态

> 有继承才有多态

- 定义：分离做什么和怎么做，将改变的事物和不变的事物分离开 <!--存在基类和与基类通讯的方法，即使新增多个导出类，导出类各种变化，与基类通讯的方法在接受导出类时依旧正常运行-->
- 用途：消除类型之间的耦合关系

## 8.1 向上转型

> 对象既可以作为自身使用，也能够作为它的基类对象使用
>
> 向上转型可能会缩小接口，但是不会窄于基类的全部接口

### 8.1.1 忘记对象类型

- 忘记对象类型：**如果一个方法接收基类对象，那这个方法也能接收基类的导出类的对象——重点**

  <!--举例：基类是哺乳动物，导出类是猴子和大熊猫，另一个不相关的类是农民。农民给动物喂食，只需要给哺乳动物传递信息，即可喂到猴子和大熊猫-->

- 用途：降低代码的冗余 <!--比如一个方法能接收基类对象，所以基类导出类的对象都能被该方法接收，而不需要为每个基类导出类重写这个方法-->

- 实现

  <!--基类-->

  ```java
  // 基类
  public class Cycle {
      protected String name;
      public Cycle() {
          this.name = "Cycle";
      }
  }
  ```

  <!--导出类-->

  ```java
  // 导出类
  public class Tricycle extends Cycle{
      public Tricycle() {
          this.name = "Tricycle";
      }
  }
  ```

  <!--向上转型及测试类-->

  ```java
  public class Test {
      static void ride(Cycle cycle){
          System.out.println(cycle.name);
      }
  
      public static void main(String[] args) {
          // 向上转型
          Cycle cycle = new Tricycle();
          ride(cycle);
      }
  }/* output
  Tricycle
  */
  ```

  

## 8.2

### 8.2.1 方法调用绑定

- 绑定：方法调用(对象.方法名)和方法主体(方法的实现)之间关联
- 分类
  - 前期绑定：在程序运行前绑定。java中的static和final符合
  - 后期绑定（动态绑定）：在运行时绑定。除java中的static和final方法(private方法属于隐式final)

### 8.2.2 产生正确的行为

> Java中的所有方法都是通过动态绑定来实现多态，因此编写只与基类交互的方法，导出类都可以运行

### 8.2.3 可扩展性

> 设计良好的OOP程序，大多数方法都会遵循与基类通讯的规则，以保持良好的可扩展性

### 8.2.4 缺陷：“覆盖”私有方法

- 注意点

  因为私有方法无法被覆盖，所以导出类中存在“覆盖”基类中的private方法将会失败而作为新的方法。因此在导出类中，对基类的private方法，最好不重名

### 8.2.5 缺陷：域与静态方法

- 注意点

  **静态方法是和类关联，而不是和单个对象，因此静态方法无法表现出多态**

- 实现

  <!--基类-->

  ```java
  // base class -StaticSub
  public class StaticSuper {
      static String staticGet(){
          return "Super staticGet";
      }
      String dynamicGet(){
          return "Super dynamicGet";
      }
  }
  ```

  <!--导出类-->

  ```java
  public class StaticSub extends StaticSuper {
      static String staticGet(){
          return "Sub staticGet";
      }
      String dynamicGet(){
          return "Sub dynamicGet";
      }
  }
  ```

  <!--测试类-->

  ```java
  public class TestS {
      public static void main(String[] args) {
          StaticSuper staticSuper = new StaticSub();
        	// 打印动态方法返回值
          print(staticSuper.dynamicGet());
          // 打印静态方法返回值
          print(staticSuper.staticGet());
      }
  }/* output
  Sub dynamicGet
  Super staticGet
  */
  ```

## 8.3 构造器和多态

> 构造器实际上是static方法，隐式

### 8.3.1 构造器的调用顺序

1. **调用基类构造器：反复递归，直到层次结构的根**
2. **按照声明顺序调用成员的初始化方法**
3. **调用导出类构造器主体**

### 8.3.2 继承和清理

> 导出类在执行清理方法时，必须同时调用基类的清理方法

### 8.3.3 构造器内部的多态方法的行为

- 问题：在基类的构造器内部调用导出类中重写基类的动态方法，如果该动态方法操纵某个成员，则会出现该成员还未初始化就被调用的情况

- 原因：**在任何事物之前，会将分配给对象的存储空间初始化为二进制的零**。这就是实现中，输出结果“Cat run i:0”为零的原因。

- 实现

  <!--基类-->

  ```java
  // base class
  class Animal {
      void run(){
          print("Ani Run");
      }
      // 构造函数
      Animal() {
          print("Ani Con before run()");
          // 多态，因此会调用导出类中的run方法
          run();
          print("Ani Con after run()");
      }
  }
  ```

  <!--导出类-->

  ```java
  class Cat extends Animal{
      private int i = 1;
  
      Cat(int r) {
          this.i = r;
          print("Cat Con i:"+i);
      }
      @Override
      void run(){
          print("Cat run i:"+i);
      }
  }
  
  ```

  <!--测试类-->

  ```java
  public class TestAC {
      public static void main(String[] args) {
          new Cat(5);
      }
  }/* output
  Ani Con before run()
  Cat run i:0
  Ani Con after run()
  Cat Con i:5
  */
  ```

  ## 8.4 协变返回类型

  > Java1.4以前，子类覆盖父类方法，必须方法名和返回值相同
  >
  > Java5.0之后，子类覆盖父类方法，保证方法名相同，返回值可以是父类的子类，可以使得返回值更加具体

## 8.5 用继承进行设计

> 用继承表达行为间的差异，并用字段表达状态上的变化

- 解读：通过继承获得两个不同的类，用来表达共有方法的不同（两个导出类分别重写方法）。而运用组合来改变自身的状态（将成员赋值为不同的对象）。

### 8.5.1 纯继承和扩展

- 纯继承：基类中已经建立的方法被导出类中覆盖，导出类没有添加任何新方法
- 扩展的缺陷：如果发生向上转型，则导出类中扩展的方法将无法使用

### 8.5.2 向下转型和运行时类型识别

- 向下转型：在继承层次中向下移动

- 格式：子类类型 变量名 = (子类类型)父类变量名

- 注意点

  Java中，所有转型都会得到检查，如果异常会返回ClassCastException

## 8.6 向上和向下转型

- 格式

  ```java
  // 基类
  class Father{}
  
  // 导出类
  class Son extends Father{}
  
  // 向上转型
  // 基类类型 变量名 = new 导出类类型
  class Test{
    public static void main(String[] args){
      Father father = new Son();
      father.smell(); //调用的是son的smell方法
    }
  }
  
  // 向下转型
  // 导出类类型 变量名 = （导出类类型）基类变量名
  class Test{
    public static void main(String[] args){
      Father fatherToSon = new Father();
      Son son = (Son)fatherToSon;
      son.laugh(); //如果laugh是son中新增的方法，则当前方法调用报错：ClassCastException
    }
  }
  ```