# 1. 对象导论

## 1.1 抽象过程

1. 面向对象的语言有五个特点

   - 万物皆为对象

   - 程序是对象的集合，它们通过发消息来通讯

     <!--一盏电灯是一个程序，灯泡、灯座则为对象-->

   - 每个对象都有自己的由其他对象所构成的存储

   - 每个对象都有类型

   - 某特定类型的所有对象都能收到同样的消息

      <!--父类几何体，子类圆形、正方形，子类对象都能收到几何体类型的信息-->
   
2. Java五大原则

   - 单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。 
   - 开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 
   - Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。 
   - 依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 
   - 接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口

## 1.2 每个对象都有一个接口

1. 发送消息（产生请求）：当向对象发送请求时，相关联的方法就会被调用

> 每个对象都是定义了特性和行为的某个特定的类

## 1.3 每个对象都提供服务

> 把对象看成服务提供者，有利于形成对象的高内聚

## 1.4 访问指定词

<!--被隐藏的具体实现-->

1. 访问指定词
   - public：任何人都能访问
   - private：仅类型的创建者和类型内部方法能够使用
   - protected：除类型的创建者和类型内部方法能够使用；继承的类也能访问（与private的区别）
   - 默认（包访问权限）：同一个包中的能够访问

## 1.5 复用具体实现

1. 组合：使用现有的类合成新的类，经常被视为（has-a）拥有关系
2. 聚合：动态发生的组合

## 1.6 继承

1. 定义：以现有类为基础，复制出副本，并在副本上修改和添加来创建新类
   - 现有类称为基类、源类、父类
   
- 副本类称为导出类、继承类、子类
  
   - **通过继承产生的类型具有类型等价性**
   
     <!--发给基类对象的消息同时也能发给导出类-->
   
2. 使基类和导出类差异的两个方法

   - 在导出类添加新方法
   - 在导出类中改变基类的方法（简称覆盖）

### 1.6.1 继承的分类

1. 纯粹替代（也称替代原则）：用一个导出类对象来完全替代一个基类对象
2. 不完全替代：在导出类中扩展接口，但基类无法访问新添加的方法



## 1.7 多态

1. 泛化：处理类型的层次结构时，不把对象当作特定类型处理，而是作为基类的对象处理

   <!--比如处理三角形、圆形、矩形，不作为特殊类处理，而是统一看成形状，因为都有绘制、移动等方法-->

   > 面向对象程序设计的最重要妙诀：编译器不可能产生传统意义上的函数调用，而是采用前期绑定和后期绑定的方法

2. 后期绑定：向对象发送消息时，被调用的代码直到运行时才能确定；再运行前，编译器仅仅确认调用方法的存在、被调用参数和返回值类型检查

   > **由于OOP中，动态绑定是默认行为，所以程序直到运行时才确定代码的位置；根据消息来确定具体调用的代码，因此是动态的**

3. 多态：同一事物在不同场景下的多种形态

   - 由于动态绑定是默认行为，所以在运行前无法确定调用的代码，因此根据消息来执行后期绑定，实现多态

     <!--示例代码-->

     **当draw()消息发到一个匿名Shape时，会基于该Shape的实际类型产生正确的行为**

     ```java
     void doSomething(Shape shape){
     	shape.draw();
       shape.rease();
     }
     ```

     ```java
     Circle circle = new Circle();
     Triangle triangle = new Triangle();
     Line line = new Line();
     doSomething(circle);
     doSomething(triangle);
     doSomething(line);
     ```

     

## 1.8单根继承结构

1. 单根继承：所有类最终都继承自单一的基类
2. 优势
   - 保证所有对象一定具备某些功能，方便执行基本操作
   - 方便垃圾回收，因为所有对象都能确定类型

## 1.9容器

1. 实际开发中，需要选择合适容器，原因为
   - 不同容器有各自的接口和行为
   - 不同容器效率不同

### 1.9.1参数化类型

1. 范型：参数化类型，使用一对尖括号，中间包含类型信息

   ```java
   ArrayList<Shape> shapes = new ArrayList<Shape>();
   ```

2. 向下转型：向下转型成为更加具体的类

   - 向下转型的行为存在风险，会出现异常

   <!--比如：Circle是Shape的一个类，但是无法得知某个Object是Shape类还是Circle类-->



## 1.10对象的创建和生命周期

1. 对象的存储
   - 对象置于堆栈或静态存储区域来实现：牺牲灵活性，存储空间分配优先考虑
   - 在堆（heap）的内存池中动态的创建对象：保证灵活性，但直到运行时才知道对象数量
   - Java采用动态内存分配方式
2. 对象的生命周期
   - java有垃圾回收器，因此能够自动释放对象占用的内存
   - C++需要手动销毁对象，不然可能导致内存泄漏



## 1.11异常处理：处理错误

> 异常处理提供了一种从错误状态进行可靠恢复的途径



## 1.12并发编程

1. 线程：彼此独立运行的部分
2. 并发：多个线程同时运行

## 1.13Java与Internet

### 1.13.1Web

1. 服务器：信息存储池、用于分发信息的软件以及信息和软件所驻留的机器或机群

### 1.13.2客户端编程

1. 通用网关接口（CGI）：数据表单的提交通过CGI传递
2. 插件（plug-in）：下载一段代码，插入到浏览器中适当位置，来扩展浏览器功能