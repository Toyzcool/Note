## 一.类加载

- 在Java代码中，类型（Class）的加载、连接与初始化都是在程序运行期间（runtime）完成的

  <!--加载：其中一种情况是将Class文件从磁盘加载到内存中-->

- 过程

  1. 加载：查找并加载类的二进制数据

  2. 连接

     - 验证：确保被加载类的正确性
     - 准备：为类变量分配内存，并将其初始化为默认值
     - 解析：把类中的符号引用转换为直接引用

  3. 初始化：为类的静态变量赋于正确的初始值

     <!--实现-->

     ```java
     public class Test{
       public static String s = "ABC";
     }
     /* conclusion
     1.连接-准备：将s变量分配内存，同时初始化为null
     2.连接-解析：s为符号引用，将s指向字符串"ABC"，即是符号引用转换为直接引用
     3.初始化：将s值赋值为"ABC"
     ```

  4. 使用

  5. 卸载
  
- Java虚拟机生命周期结束

  1. 执行System.exit( )方法
  2. 程序正常结束
  3. 程序在执行过程中遇到异常或错误而异常终止
  4. 操作系统错误而导致Java虚拟机终止

## 1.1 类加载器

#### 1.基本概念

- 作用：将类加载到Java虚拟机中 

- 分类
  
  - Java虚拟机自带的类加载器
    1. 根类加载器（Bootstrap）
    2. 扩展类加载器（Extension）
    3. 系统（应用）类加载器（System）
  - 用户自定义的类加载器
    1. java.lang.ClassLoader子类
    2. 用户定制类的加载方式
  
- 规则

  - JVM规范允许类加载器在预料某个类需要使用前就预先加载，在加载过程中遇到.class文件缺失，则需要等到程序主动使用类时才抛出异常 <!--如果一直没有主动使用，则不会抛出异常-->

- 获取方式

  - 获得当前类的ClassLoader：class.getClassLoader( )
  - 获得线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader( )
  - 获得系统的ClassLoader：ClassLoader.getSystemClassLoader( )
  - 获得调用者的ClassLoader：DriverManager.getCallerClassLoader( ) <!--使用较少-->

- 实现：遍历输出Java虚拟机自带的类加载器

  ```java
  public class TestTraverseClassLoader {
      public static void main(String[] args) {
          ClassLoader classLoader = ClassLoader.getSystemClassLoader();
          System.out.println(classLoader);
          while (null != classLoader){
              classLoader = classLoader.getParent();
              System.out.println(classLoader);
          }
      }
  }
  /* output
  jdk.internal.loader.ClassLoaders$AppClassLoader@3d4eac69
  jdk.internal.loader.ClassLoaders$PlatformClassLoader@38af3868
  null
  */
  /* conclusion
  1.根类加载器输出结果为null
  */
  ```

#### 2.双亲委托机制

- 原理图

  <!--加载器之间不是继承关系-->

  ![](assets/1.类加载器双亲委托.png)

  <!--解析-->

  1.流程

  1. Sample类加载时，首先检查用户自定义的类加载器Loader1，然后检查父加载器（系统加载器）是否已经加载，未加载则再向上检查，直到检查到根类加载器
  2. 然后根类加载器尝试加载，由于根目录文件中不存在类的class文件，因此无法加载，则交给扩展类加载器，扩展类加载器无法加载则交给系统类加载器，系统类加载器能够加载（是程序默认的加载器），因此加载完成

  2.定义类加载器 定义：真正加载类的加载器（图中的系统类加载器）

  2.初始化加载器 定义：所有能返回Class对象的加载器（包括定义类加载器）称为初始化加载器

- 实现

  ```java
  public class TestLoader {
      public static void main(String[] args) throws Exception {
          // 由根加载器加载的类
          Class<?> class1 = Class.forName("java.lang.String");
          System.out.println(class1.getClassLoader());
  
          // 由系统类加载器加载的类
          Class<?> cClass = Class.forName("ClassLoader.C");
          System.out.println(cClass.getClassLoader());
      }
  }
  class C{ }
  
  /* output
  null
  jdk.internal.loader.ClassLoaders$AppClassLoader@3d4eac69
  */
  /* conclusion
  1.由于String类能够被根类加载器加载，因此输出结果为null
  */
  ```

## 1.2 类的加载

#### 1.基本概念

- 类的加载 定义：将类的.class文件中的二进制数据加载到内存中，将其放置在运行区的方法区中，并在内存中创建java.lang.Class对象来封装类在方法区中的数据结构 <!--可以联系反射的内容-->

  ![](assets/5.反射机制.jpg)

- 方式

  - 从本地系统中直接加载
  - 通过网络下载.class文件
  - 通过jar包中加载
  - 从专有数据库中提取
  - **将Java源文件动态编译为.class文件** （动态代理时使用）

#### 2.接口

- 规则

  - **如果调用接口中的静态常量，接口根本不会加载；如果调用接口实现类中的静态常量，类和接口都不会加载**

    **原因：static和final共同修饰为静态常量，会直接纳入常量池。而接口中的变量默认有static和final修饰**

    <!--实现-->

    ```java
    public class TestInterface {
        public static void main(String[] args) {
            System.out.println(Sub.b);
        }
    }
    interface Super{
        int a = 5;
    }
    interface Sub extends Super{
        int b =6; // 接口中的变量默认为static和final
    }
    /* output
    [0.184s][info   ][class,load] ClassLoader.TestInterface 
    6
    */
    ```

  - **如果调用接口实现类中的静态变量，类和接口都会加载**

    <!--实现-->

    ```java
    public class TestInterface {
        public static void main(String[] args) {
            System.out.println(Sub.b);
        }
    }
    interface Super{
        int a = 5;
    }
    class Sub implements Super{
       static int b =6;
    }
    /* output
    [0.184s][info   ][class,load] ClassLoader.TestInterface 
    [0.186s][info   ][class,load] ClassLoader.Super
    [0.186s][info   ][class,load] ClassLoader.Sub
    [0.187s][info   ][class,load] ClassLoader.Super$1 
    6
    */
    
    ```



## 1.3 类的连接

### 1.3.1验证

- 作用：验证文件
  - 类文件的结构检查
  - 语义检查
  - 字节码验证
  - 二进制兼容性检查

### 1.3.2准备

- 作用：为变量分配空间，并赋值为默认值

- 实现

  ```java
  public class TestPreparation {
      public static void main(String[] args) {
          Singleton singleton = Singleton.getSingleton();
          System.out.println("counter1:"+Singleton.counter1);
          System.out.println("counter2:"+Singleton.counter2);
      }
  }
  class Singleton{
      static int counter1 = 1;
      private static Singleton singleton = new Singleton();
  
      private Singleton(){
          counter1++;
          counter2++;
      }
  
      static int counter2 = 0;
      static Singleton getSingleton(){
          return singleton;
      }
  }
  /* output
  counter1:2
  counter2:0
  */
  ```

  <!--解析-->

  1.流程解析

  1. 准备阶段，静态变量counter1赋值为0；静态变量singleton赋值为null；静态变量counter2赋值为0
  2. 初始化阶段，静态变量counter1赋值为1；静态变量singleton指向类Singleton的对象实例，导致调用类的构造方法，将counter1赋值为2，counter2赋值为1；静态变量counter2赋值重新为0
  3. 因此输出counter1为2；counter2为0

## 1.4 类的初始化

### 1.4.1 基本概念

> Java对类的使用方式分为主动使用和被动使用

- 初始化 条件：类或者接口只有在“**首次主动使用**”时才被初始化

  <!--1.初始化只有一次。2.必须要主动使用-->

- 初始化 规则

  1. 如果类未加载和连接，则先进行加载和连接

  2. 如果类存在父类且未初始化，则先将父类初始化

     <!--初始化类时，不会初始化它实现的接口；初始化接口时，不会初始化它的父接口-->

  3. 如果类中存在初始化语句，则依次执行初始化语句

- 主动使用 方式

  1. 创建类的实例对象

  2. 访问类或接口的静态变量或者给类或者接口的静态变量赋值

     <!--如果静态变量定义在父类中，通过子类访问父类中的静态变量，则只会初始化父类-->

     <!--实现-->

     ```java
     public class TestClassLoader {
         public static void main(String[] args) {
             System.out.println("-----Child.str1-----");
             System.out.println(Child.str1);
         }
     
     }
     
     class Parent{
         static String str1 = "hello world";
         static {
             System.out.println("Parent static block");
         }
     }
     
     class Child extends Parent{
         static String str2 = "welcome";
         static {
             System.out.println("Child static block");
         }
     }
     /* output
     -----Child.str1-----
     Parent static block
     hello world
     */
     /* conclusion
     1.对于静态变量，只有直接定义了该变量的类才会被初始化
     */
     ```

  3. 调用类的静态方法

     <!--如果静态方法定义在父类中，通过子类访问父类中的静态方法，则只会初始化父类-->

     <!--实现-->

     ```java
     class TestLauncher {
         static {
             System.out.println("TestLauncher static");
         }
     
         public static void main(String[] args) {
             TestSub.doSomething();
         }
     }
     
     class TestSuper{
         static int a = 3;
         static {
             System.out.println("Super static");
         }
         static void doSomething(){
             System.out.println("Super doSomething");
         }
     }
     
     class TestSub extends TestSuper{
         static int b = 4;
         static {
             System.out.println("Sub static");
         }
     }
     /* output
     TestLauncher static
     Super static
     Super doSomething
     */
     ```

  4. 反射

     <!--实现-->

     ```java
     class TestClass{
         static {
             System.out.println("TestClass Init");
         }
     }
     
     public class TestLoaderAndReflex {
         public static void main(String[] args) throws Exception {
             // 使用ClassLoader的loadClass方法加载类
             ClassLoader classLoader = ClassLoader.getSystemClassLoader();
             Class<?> class1 = classLoader.loadClass("ClassLoader.TestClass");
             System.out.println(class1);
             System.out.println("------------");
             Class<?> class2 = Class.forName("ClassLoader.TestClass");
             System.out.println(class2);
     
         }
     }
     /* output
     class ClassLoader.TestClass
     ------------
     TestClass Init
     class ClassLoader.TestClass
     */
     ```

  5. 初始化类的子类 <!--接口不适用-->

     <!--实现-->

     ```java
     public class TestClassLoader {
         public static void main(String[] args) {
             System.out.println("-----Child.str2-----");
             System.out.println(Child.str2);
         }
     }
     
     class Parent{
         static String str1 = "hello world";
         static {
             System.out.println("Parent static block");
         }
     }
     
     class Child extends Parent{
         static String str2 = "welcome";
         static {
             System.out.println("Child static block");
         }
     }
     /* output
     -----Child.str2-----
     Parent static block
     Child static block
     welcome
     */
     /* conclusion
     1.由于子类静态变量被访问，因此子类被初始化
     2.因为子类被初始化，因此超类也被初始化
     */
     ```

  6. Java虚拟机启动时被标记为启动类的类

     <!--举例-->

     ```java
     public class TestLauncher {
         static {
             System.out.println("TestLauncher static");
         }
     
         public static void main(String[] args) {
             System.out.println(TestSub.b);
         }
     }
     
     class TestSuper{
         static int a = 3;
         static {
             System.out.println("Super static");
         }
     }
     
     class TestSub extends TestSuper{
         static int b = 4;
         static {
             System.out.println("Sub static");
         }
     } 
     /* output
     TestLauncher static
     Super static
     Sub static
     4
     */
     ```

  7. REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类如果未初始化则初始化

- 被动使用 方式：除主动使用之外的情况

### 1.4.2 不同类型

#### 1.常量

- 规则

  - 常量在编译阶段会存入到调用这个常量的方法所在类的常量池中。调用类并不会直接引用定义常量的类，因此不会触发定义常量的类的初始化

    <!--实现-->

    ```
    public class TestFinal {
        public static void main(String[] args) {
            System.out.println(TestBase.s);
        }
    }
    class TestBase{
        static final String s = "ABC";
    
        static {
            System.out.println("TestBase Build");
        }
    }
    /* output
    ABC
    */
    /* conclusion
    1.调用常量时，定义常量的TestBase类并没有被初始化，通过-XX:+TraceClassLoading发现TestBase类未加载
    2.因此在编辑阶段，s常量会存入调用这个常量的方法（main方法）所在类（TestFinal）的常量池中
    3.即使在编译后将TestBase的class文件删除，常量也能正常输出
    */
    ```

  - 如果常量在编译期无法确定，则将初始化定义常量所在的类

    <!--实现-->

    ```java
    public class TestFinal {
        public static void main(String[] args) {
            System.out.println(TestBase.sRandom);
        }
    }
    class TestBase{
        static final String sRandom = UUID.randomUUID().toString();
    
        static {
            System.out.println("TestBase Build");
        }
    }
    /* output
    TestBase Build
    fedb4d78-ff59-4810-ad80-60f468707e77
    */
    ```

#### 2.数组

- 规则

  - 对于数组实例，其类型是在JVM在运行期间动态生成的（不会触发类的初始化）。动态生成的类型，其父类型就是java.lang.Object

    <!--实现-->

    ```java
    public class TestArray {
        public static void main(String[] args) {
            SubTest subTest = new SubTest();
            System.out.println("subTest.getClass():"+subTest.getClass());
            System.out.println("=============");
            SubTest[] subTests = new SubTest[1];
            System.out.println("subTests.getClass():"+subTests.getClass());
            System.out.println("subTests.getClass().getSuperclass():"+subTests.getClass().getSuperclass());
            System.out.println("=============");
            SubTest[][] subTestsMulti = new SubTest[1][1];
            System.out.println("subTestsMulti.getClass():"+subTestsMulti.getClass());
            System.out.println("subTestsMulti.getClass().getSuperclass():"+subTestsMulti.getClass().getSuperclass());
        }
    }
    class SubTest{
        static {
            System.out.println("SubTest Build");
        }
    }
    /* output
    SubTest Build
    subTest.getClass():class ClassLoader.SubTest
    =============
    subTests.getClass():class [LClassLoader.SubTest;
    subTests.getClass().getSuperclass():class java.lang.Object
    =============
    subTestsMulti.getClass():class [[LClassLoader.SubTest;
    subTestsMulti.getClass().getSuperclass():class java.lang.Object
    */
    ```

#### 3.接口

- 规则——重点

  - 当接口初始化时，不要求父类接口初始化

    <!--实现：接口未初始化-->

    ```java
    public class TestInterface {
        public static void main(String[] args) {
            System.out.println(Sub.THREAD);
        }
    }
    interface Super{
        Thread THREAD = new Thread(){
            {
                System.out.println("Super 线程初始化");
            }
        };
    }
    interface Sub extends Super{
        Thread THREAD = new Thread(){
            {
                System.out.println("Sub 线程初始化");
            }
        };
    }
    /* output
    Sub 线程初始化
    Thread[Thread-0,5,main]
    */
    /* conclusion
    1.未输出“Super 线程初始化”，因此父类接口未初始化
    */
    ```

  - 当类初始化时，并不会要求实现的接口初始化

    <!--实现-->

    ```Java
    public class TestInterface {
        public static void main(String[] args) {
            System.out.println(Sub.b);
        }
    }
    interface Super{
        int a = 5;
        Thread THREAD = new Thread(){
            {
                System.out.println("线程初始化");
            }
        };
    }
    class Sub implements Super{
        static int b =6;
    }
    /* output
    6
    */
    /* conclusion
    1.未输出“线程初始化”，因此接口未初始化
    */
    ```

  - 只有使用到父类接口（如引用到父类接口中定义的变量），父类才会初始化

    注意：因为接口中变量默认为static和final修饰，如果是在编译期能够确认的变量，则父类不会初始化，而是纳入常量池

    <!--实现：父类接口初始化-->

    ```java
    public class TestInterface {
        public static void main(String[] args) {
            System.out.println(Sub.a);
        }
    }
    interface Super{
        String a = UUID.randomUUID().toString();
        Thread THREAD = new Thread(){
            {
                System.out.println("Super 线程初始化");
            }
        };
    }
    interface Sub extends Super{
        Thread THREAD = new Thread(){
            {
                System.out.println("Sub 线程初始化");
            }
        };
    }
    /* output
    Super 线程初始化
    381c544d-3640-4ef6-bac5-5a32cddcd11a
    */
    /* conclusion
    1.编译期时，String类型的s变量无法确认，因此父类接口将初始化
    */
    ```

    <!--实现：父类接口不初始化-->

    ```java
    public class TestInterface {
        public static void main(String[] args) {
            System.out.println(Sub.a);
        }
    }
    interface Super{
        String a = "ABC";
        Thread THREAD = new Thread(){
            {
                System.out.println("Super 线程初始化");
            }
        };
    }
    interface Sub extends Super{
        Thread THREAD = new Thread(){
            {
                System.out.println("Sub 线程初始化");
            }
        };
    }
    /* output
    ABC
    */
    /* conclusion
    1.编译期时，String类型的s变量确认，因此父类接口不会初始化
    */
    ```

## 1.5 流程总结

1. 加载：查找二进制文件并读取到Java虚拟机中

2. 连接

   1. 验证
   2. 准备：为类变量分配内存，同时赋予默认值
   3. 解析：将符号引用转换成直接引用

3. 初始化：为类变量赋于正确的初始值

4. 类实例化

   1. 为新的对象分配内存

   2. 为实例变量赋予默认值

   3. 为实例变量赋予正确的初始值

      <!--Java编译器为每一个类至少生成一个实例初始化方法，在java的class文件中，称为<init>。针对源代码中的每一个构造方法，都生成一个<init>-->

## 1.6 加载参数

- 格式
  - -XX:+<option>：开启option选项
  - -XX:-<option>：关闭option选项
  - -XX:<option>=<value>：将option值赋值为value

#### 1.-XX:+TraceClassLoading

- 作用：用于追踪类的加载信息并打印出来









