# 类加载

- 在Java代码中，类型（Class）的加载、连接与初始化都是在程序运行期间（runtime）完成的

  <!--加载：其中一种情况是将Class文件从磁盘加载到内存中-->

- 过程

  1. 加载：查找并加载类的二进制数据

  2. 连接

     - 验证：确保被加载类的正确性
     - 准备：为类的静态变量分配内存，并将其初始化为默认值
     - 解析：把类中的符号引用转换为直接引用

  3. 初始化：为类的静态变量赋于正确的初始值

     <!--实现-->

     ```java
     public class Test{
       public static String s = "ABC";
     }
     /* conclusion
     1.连接-准备：将s变量分配内存，同时初始化为null
     2.连接-解析：s为符号引用，将s指向字符串"ABC"，即是符号引用转换为直接引用
     3.初始化：将s值赋值为"ABC"
     ```

  4. 使用

  5. 卸载

#### 1.类加载器

- Java虚拟机生命周期结束
  1. 执行System.exit( )方法
  2. 程序正常结束
  3. 程序在执行过程中遇到异常或错误而异常终止
  4. 操作系统错误而导致Java虚拟机终止

#### 2.类的加载

- 类的加载 定义：将类的.class文件中的二进制数据加载到内存中，将其放置在运行区的方法区中，并在内存中创建java.lang.Class对象来封装类在方法区中的数据结构 <!--可以联系反射的内容-->

  ![](assets/5.反射机制.jpg)

- 方式

  - 从本地系统中直接加载
  - 通过网络下载.class文件
  - 通过jar包中加载
  - 从专有数据库中提取
  - **将Java源文件动态编译为.class文件** （动态代理时使用）

#### 4.类的初始化

> Java对类的使用方式分为主动使用和被动使用

- 初始化条件：类或者接口只有在“**首次主动使用**”时才被初始化

  <!--1.初始化只有一次。2.必须要主动使用-->

- 主动使用的情况

  1. 创建类的实例对象

  2. 访问类或接口的静态变量或者给类或者接口的静态变量赋值

     <!--实现-->

     ```java
     public class TestClassLoader {
         public static void main(String[] args) {
             System.out.println("-----Child.str1-----");
             System.out.println(Child.str1);
         }
     
     }
     
     class Parent{
         static String str1 = "hello world";
         static {
             System.out.println("Parent static block");
         }
     }
     
     class Child extends Parent{
         static String str2 = "welcome";
         static {
             System.out.println("Child static block");
         }
     }
     /* output
     -----Child.str1-----
     Parent static block
     hello world
     */
     /* conclusion
     1.对于静态变量，只有直接定义了该变量的类才会被初始化
     */
     ```

  3. 调用类的静态方法

     ```
     invokestatic
     ```

  4. 反射

     ```java
     Class.forName("com.Test")
     ```

  5. 初始化类的子类

     <!--实现-->

     ```java
     public class TestClassLoader {
         public static void main(String[] args) {
             System.out.println("-----Child.str2-----");
             System.out.println(Child.str2);
         }
     }
     
     class Parent{
         static String str1 = "hello world";
         static {
             System.out.println("Parent static block");
         }
     }
     
     class Child extends Parent{
         static String str2 = "welcome";
         static {
             System.out.println("Child static block");
         }
     }
     /* output
     -----Child.str2-----
     Parent static block
     Child static block
     welcome
     */
     /* conclusion
     1.由于子类静态变量被访问，因此子类被初始化
     2.因为子类被初始化，因此超类也被初始化
     */
     ```

  6. Java虚拟机启动时被标记为启动类的类

     <!--举例-->

     ```java
     public class TestClassLoader {
         public static void main(String[] args) {
         }
     }
     /* conclusion
     1.TestClassLoader被标记为启动类，因为存在main方法
     */
     ```

  7. REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类如果未初始化则初始化

- 被动使用的情况：除主动使用之外的情况













